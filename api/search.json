[{"id":"20a7da5a5694f08bc83b1c325a79dd48","title":"(分段分表锁)使用Golang实现一个并发安全的Map","content":"\n\n\n\n\n\n\n\n\n上回说到，用Golang实现了一个高性能的kv，并且优化了锁的操作，今天我们就使用分段分表锁的思路，来将我们的Map性能提升到一个新的高度，相关视频教程在全文的最后，可以点击目录中的锚点快速前往\n本blog的对应GitHub仓库为: sunist-c/toy-framework，将作为toy-framework的组件存在，可能随toy-framework一同更新\n思路问题产生go内置的map是并发不安全的，比如在下面的函数中：\nfunc Function() {\n    m := make(map[int]int)\n    for i := 0; i &lt; 100; i++ {\n        go func(index int) {\n            key, value := index, rand.Int()\n            m[key] = value\n            v, ok := m[key]\n            fmt.Printf(\"%v-%v\\n\", ok, v == value)\n        }(i)\n    }\n}\n\n我们启用了100个go程，并发地向m := map[int]int写入数据，甚至没有对同一个key值进行操作，但是在实际执行的过程中，这个函数会报下面的panic：\nfatal error: concurrent map writes\n\n造成这个问题的原因是，go内置的map的存储底层结构是bucket，默认情况下，每个bucket可以存储八个Key-Value pair，但是当bucket已经存储满八个KV对以后，便会触发map的扩容机制(此机制不在此处展开)，扩容中的map是无法进行操作的，若一个goroutine对map进行写操作并且触发扩容机制时，此时其他goroutine继续操作这个map的话，便会报出上面所述的concurrent map writes\n简单改进解决上面这一问题最简单的方法便是对map加一个锁，同一时间只允许一个goroutine对map进行操作，其余goroutine都需要等待正在进行操作的goroutine完成操作释放锁后，再进行竞争并获取锁\n于是我们的map便成为了下面的样子：\ntype AnotherMap[Key, Value any] struct {\n    mu *sync.Mutex\n    mp map[any]Value\n}\n\n\n\n\n\n\n\n\n\n\n上面这段代码采用了go 1.18及以上版本的泛型(Generics)语法，实际采用时请注意go语言版本\n我们在对AnotherMap进行操作前，对应的函数都需要将mu进行Lock()操作，操作完成后进行UnLock()操作，以此来保证同一时间只能有一个goroutine能够对mp进行操作\n\n\n\n\n\n\n互斥锁的特征\n互斥锁(Mutex)具有以下特征：\n\n锁有且仅有Locked和Unlocked两个状态\n当锁处于Locked状态时，其他goroutines都不能申请锁\n当锁处于Unlocked状态时，其他goroutines才可以申请锁\n\n即同一时间最多只能有一个goroutine可以对锁进行占用\n\n这个改进的实现代码如下：\n\n点击展开以显示代码\npackage toy_kv\n\nimport (\n\t\"sync\"\n)\n\ntype CommonMap[Key, Value any] struct {\n\tmu *sync.Mutex\n\tm  map[any]Value\n}\n\nfunc (c *CommonMap[Key, Value]) Load(key Key) (value Value, ok bool) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tgot, gotten := c.m[key]\n\treturn got, gotten\n}\n\nfunc (c *CommonMap[Key, Value]) Store(key Key, value Value) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tc.m[key] = value\n}\n\nfunc (c *CommonMap[Key, Value]) Delete(key Key) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tdelete(c.m, key)\n}\n\nfunc (c *CommonMap[Key, Value]) Range(f func(key Key, value Value) bool) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\tfor k, v := range c.m {\n\t\tif !f(k.(Key), v) {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc NewCommonMap[Key, Value any]() IMap[Key, Value] {\n\treturn &amp;CommonMap[Key, Value]{\n\t\tmu: &amp;sync.Mutex{},\n\t\tm:  make(map[any]Value),\n\t}\n}\n\n\n但是，由于我们使用了互斥锁，导致了并发请求在实际处理的时候，其实是串行处理，而不是并行处理的，导致了我们的map并行性能和串行性能其实是没有差别的，进而产生相关的性能问题\n进一步改进但当我们仔细审视上面那个简单粗暴的，使用互斥锁的改进后，我们不难发现一个问题：\n当map没有进行写操作(即可能造成扩容、缩桶情况)的时候，此时map时可以进行并发读的，并且无论多少个goroutine进行并发读取，map都是安全的\n\n\n\n\n\n\n读写锁的特征\n读写锁(RWMutex)具有下面的特征：\n\n锁分为ReadLock(读锁)和WriteLock(写锁)\n当锁的类型为ReadLock的时候，不可以申请WriteLock，反之亦然\n当锁的类型为ReadLock的时候，其他goroutines可以继续申请ReadLock\n当锁的类型为WriteLock的时候，其他goroutines不可以继续申请WriteLock\n\n\n\n读写锁的特征与我们map的情况相当一致，所以我们就可以使用读写锁来对map进行并发控制，在进行读操作的时候，我们申请读锁，在进行写操作的时候，我们申请写锁，由此来最大限度地保证单个map被最大程度地使用\n那么现在我们的map便变成了下面的结构：\ntype AnotherMap[Key, Value any] struct {\n\tmu *sync.RWMutex\n\tmp map[any]Value\n}\n\n这个改进的实现代码如下：\n\n点击展开以显示代码\npackage toy_kv\n\nimport \"sync\"\n\ntype SimpleMap[Key, Value any] struct {\n\tmu *sync.RWMutex\n\tmp map[any]Value\n}\n\nfunc (m *SimpleMap[Key, Value]) Load(key Key) (value Value, ok bool) {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\tgot, gotten := m.mp[key]\n\treturn got, gotten\n}\n\nfunc (m *SimpleMap[Key, Value]) Store(key Key, value Value) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tm.mp[key] = value\n}\n\nfunc (m *SimpleMap[Key, Value]) Delete(key Key) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tdelete(m.mp, key)\n}\n\nfunc (m *SimpleMap[Key, Value]) Range(f func(key Key, value Value) bool) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tfor k, v := range m.mp {\n\t\tif !f(k.(Key), v) {\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc NewSimpleMap[Key, Value any]() IMap[Key, Value] {\n\treturn &amp;SimpleMap[Key, Value]{\n\t\tmu: &amp;sync.RWMutex{},\n\t\tmp: map[any]Value{},\n\t}\n}\n\n\n更进一步改进在上面的「进一步改进」中，我们不难发现，其实我们的map在读的时候是并行操作的，但是在写的时候是串行操作的，并且同一时刻只能进行读或者写中的一种操作，无法同时进行读和写。那有没有一种可能，我们可以让我们的map同时进行读和写，并且读和写都是并行操作呢\n答案是肯定的，我们可以使用分表的思路：将我们的大map分为多份小map，这样，当其中一个map在进行写操作时，其余map依旧可以进行写操作，达到了支持并发读与并发写的效果。并且，当我们的分表足够多，且元素细分足够均匀的情况下，对其中一个分表的Lock操作造成的影响于整个大map而言，就可以忽略不计了\n由此，我们的map就变成了这个样子：\ntype Table[Key, Value any] struct {\n\tmu *sync.RWMutex\n\tmp map[any]Value\n}\n\ntype AnotherMap[Key, Value any] struct {\n\ttables map[uint]*Table[Key, Value]\n}\n\n我们对map进行操作时，步骤也更改为如下：\n\n对Key进行hash，确定其要存入哪张分表\n由分表具体进行操作\n\n这一部分的实现就请转到「实现」小节\n\n\n\n\n\n\n更更更进一步改进\n不难发现，其实造成map并发不安全的原因，就是map的扩容、缩桶机制，如果一个Key存在的话，我们对它进行重新赋值，虽然这个操作是写操作，但不会造成map的panic，所以我们可以进一步细分map的操作：\n\n新增KV\n修改KV\n删除存在的KV\n删除不存在的KV\n读取KV\n\n上面的所有「原子」操作中，只有(1)，(3)需要申请写锁，其余的操作均不需要申请写锁，照此思路进行继续改进，则map的性能也会进一步提高\n\n实现首先我们需要给出Map的接口：\ntype IMap[Key, Value any] interface {\n\t// Load 从kv中读取一个Key,获取它的Value以及是否存在\n\tLoad(key Key) (value Value, ok bool)\n\n\t// Store 向kv中存储一个Key-Value\n\tStore(key Key, value Value)\n\n\t// Delete 在kv中删除一个Key-Value\n\tDelete(key Key)\n\n\t// Range 遍历kv-map,对每一个Key-Value,均调用f,当f返回false的时候,停止遍历\n\tRange(f func(key Key, value Value) bool)\n}\n\nHash函数设计Hash函数的设计是我们分段分表锁实现Map的重中之重，因为一个好的Hash函数可以Key均匀地分布在分表中，同时也要兼顾运算速度，不能像MD5那样进行过于复杂的计算，造成时间上的浪费\n我们此处使用的Hash算法为SDBM Hash，由Ken Thompson(C语言/Unix与Golang的设计者)发明，这个Hash的主要内容如下：\nfunc sdbmHash(data []byte) uint {\n\tvar hash uint\n\tfor _, b := range data {\n\t\thash = uint(b) + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash\n\t}\n\n\treturn hash\n}\n\n这个hash的时间复杂度为，即与data的长度有关\n那么转回本文，摆在我们面前的第一个问题是，如何在不知道Key类型的情况下(不使用reflect确定类型的原因是，reflect的性能较差)，获取Key中存储的数据\n我们采用的方案是unsafe.Pointer和uintptr\n\n\n\n\n\n\nunsafe.Pointer和uintptr的特征\nunsafe.Pointer具有如下特征:\n\n任意类型的指针都可以转化为unsafe.Pointer\nunsafe.Pointer可以转化为任意类型的指针，并且忽略类型检查(即不会报错)\n\nuintptr具有如下特征:\n\nuintptr不是指针\nunsafe.Pointer可以转化为uintptr，uintptr也可以转化为unsafe.Pointer\nuintptr可以进行指针运算，即C语言的int *ptr = &amp;num; ptr++一类的操作\n使用unsafe.SizeOf(x)可以获得x类型的长度，结果为uintptr\nx的uintptr合法取值范围为: [uintptr(unsafe.Pointer(&amp;x)), uintptr(unsafe.Pointer(&amp;x))+unsafe.SizeOf(x)]\n\n\n\n使用unsafe包时，需要格外注意操作逻辑，下面是使用unsafe包的示例代码:\nfunc unsafeExample() {\n\tx := struct{\n\t\t// ...fields\n\t}{\n\t\t// ...values\n\t}\n\n\t// uintptr不是指针，需要防止x被gc释放，所以手动创建一指针指向x\n\tgc := &amp;x\n\n\t// 获取x相关的unsafe属性\n\tstartPtr := uintptr(unsafe.Pointer(gc))\n\toffset := unsafe.SizeOf(x)\n\tendPtr := startPtr + offset\n\n\t// 进行相关操作\n\tfor ptr := startPtr; ptr &lt;= endPtr; ptr += 1 {\n\t\t// y := *(*WantType)(unsafe.Pointer(ptr))\n\t\t// ...operations\n\t}\n}\n\n\n\n\n\n\n\n\n安全性警告\n需要注意的是，在实际开发的过程中，使用unsafe.Pointer和uintptr时要对自己的逻辑格外的明确，任何一点错误都可能造成严重的后果，正如包名unsafe所示\n下面是一个错误使用的范例(不要问我怎么知道的):\nfunc errorExample() {\n\t// 声明一个变量x，类型为int32，长度为4byte\n\tx := int32(0)\n\t\n\t// 将int类型的x转换为unsafe.Pointer\n\tunsafePtr := unsafe.Pointer(&amp;x)\n\n\t// 将unsafePtr强制转换为*[]byte类型的指针，并将指针解引用，赋值给bytesArr\n\tbytesArr := *(*[]byte)(unsafePtr)\n\n\t// 打印bytesArr的长度\n\tfmt.Printf(\"length of bytesArr: %v\\n\", len(bytesArr))\t\n}\n\n当我们运行上面的代码的时候，go会给我们一个惊喜，x的长度应该是，而结果却是如下所示:\n=== RUN   errorExample\nlength of bytesArr: 1374389829464\n--- PASS: errorExample (0.00s)\nPASS\n\n如果此时对bytesArr进行操作…\n\n所以，我们将直接获取Key的数据，并将其转化为[]byte，然后再通过sdmbHash()取得Key的hash值：\n\n点击展开以显示代码\nfunc hash[Key any](key Key) uint {\n\tgc := &amp;key\n\tstart := uintptr(unsafe.Pointer(gc))\n\toffset := unsafe.Sizeof(key)\n\tsizeOfByte := unsafe.Sizeof(byte(0))\n\n\thashSum := uint(0)\n\tfor ptr := start; ptr &lt; start+offset; ptr += sizeOfByte {\n\t\tb := *(*byte)(unsafe.Pointer(ptr))\n\t\thashSum += uint(b)\n\t\thashSum = uint(b) + (hashSum &lt;&lt; 6) + (hashSum &lt;&lt; 16) - hashSum\n\t}\n\treturn hashSum\n}\n\n\n总表实现我们将总表定义如下：\ntype RWMap[Key, Value any] struct {\n\ttables map[uint]*Table[Key, Value]\n\tlength uint\n}\n\ntables是分表的结构，length则为分表的数目\n我们只需要将所有传入请求的Key进行hash，然后再将请求转到对应的分表进行操作，并返回分表操作的结果即可\n\n点击展开以显示代码\ntype RWMap[Key, Value any] struct {\n\ttables map[uint]*Table[Key, Value]\n\tlength uint\n}\n\nfunc (R *RWMap[Key, Value]) Load(key Key) (value Value, ok bool) {\n\tindex := hash(key) % R.length\n\treturn R.tables[index].get(key)\n}\n\nfunc (R *RWMap[Key, Value]) Store(key Key, value Value) {\n\tindex := hash(key) % R.length\n\tR.tables[index].set(key, value)\n}\n\nfunc (R *RWMap[Key, Value]) Delete(key Key) {\n\tindex := hash(key) % R.length\n\tR.tables[index].del(key)\n}\n\nfunc (R *RWMap[Key, Value]) Range(f func(key Key, value Value) bool) {\n\tfor _, t := range R.tables {\n\t\tif !t.tRange(f) {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n\n分表实现我们将分表定义如下：\ntype Table[Key, Value any] struct {\n\tmu    *sync.RWMutex\n\tlines map[any]Value\n}\n\n分表的实现与上文的SimpleMap类似，同样通过RWMutex进行并发控制\n\n点击展开以显示代码\ntype Table[Key, Value any] struct {\n\tmu    *sync.RWMutex\n\tlines map[any]Value\n}\n\nfunc (t *Table[Key, Value]) set(key Key, value Value) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tt.lines[key] = value\n}\n\nfunc (t *Table[Key, Value]) get(key Key) (value Value, ok bool) {\n\tt.mu.RLock()\n\tdefer t.mu.RUnlock()\n\tgot, gotten := t.lines[key]\n\treturn got, gotten\n}\n\nfunc (t *Table[Key, Value]) del(key Key) {\n\tt.mu.Lock()\n\tdefer t.mu.Unlock()\n\tdelete(t.lines, key)\n}\n\nfunc (t *Table[Key, Value]) tRange(f func(Key, Value) bool) bool {\n\tfor k, v := range t.lines {\n\t\tif !f(k.(Key), v) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc NewRWMap[Key, Value any](length uint) IMap[Key, Value] {\n\trwMap := RWMap[Key, Value]{\n\t\ttables: map[uint]*Table[Key, Value]{},\n\t\tlength: length,\n\t}\n\n\tfor i := uint(0); i &lt; length; i++ {\n\t\trwMap.tables[i] = &amp;Table[Key, Value]{\n\t\t\tmu:    &amp;sync.RWMutex{},\n\t\t\tlines: map[any]Value{},\n\t\t}\n\t}\n\n\treturn &amp;rwMap\n}\n\n\n测试上文中简单改进的实现类为CommonMap，进一步改进的实现类型为SimpleMap，更进一步改进的实现类型为RWMap\n单元测试单元测试函数type TestCase[Key, Value any] struct {\n\tIndexes        []int\n\tStoreKeys      map[int]Key\n\tStoreValues    map[int]Value\n\tLoadKeys       map[int]Key\n\tWantLoadValues map[int]Value\n\tWantLoaded     map[int]bool\n\tDeleteKeys     map[int]Key\n\tRangeFunc      func(Key, Value) bool\n\tEquals         func(v1, v2 Value) bool\n}\n\nfunc UnitTestFunc[Key, Value any](m IMap[Key, Value], testCase *TestCase[Key, Value], t *testing.T) {\n\tfor _, index := range testCase.Indexes {\n\t\tm.Store(testCase.StoreKeys[index], testCase.StoreValues[index])\n\t}\n\n\tfor _, index := range testCase.Indexes {\n\t\tm.Delete(testCase.DeleteKeys[index])\n\t}\n\n\tfor _, index := range testCase.Indexes {\n\t\tgot, gotten := m.Load(testCase.LoadKeys[index])\n\t\tif gotten != testCase.WantLoaded[index] {\n\t\t\tt.Errorf(\"key %v want loaded: %v, but load: %v\", testCase.LoadKeys[index], testCase.WantLoaded[index], gotten)\n\t\t}\n\t\tif !testCase.Equals(got, testCase.WantLoadValues[index]) {\n\t\t\tt.Errorf(\"key %v want got: %v, but got: %v\", testCase.LoadKeys[index], testCase.WantLoadValues[index], got)\n\t\t}\n\t}\n\n\tm.Range(testCase.RangeFunc)\n}\n\n单元测试内容func TestCommonMap(t *testing.T) {\n\tt.Run(\"test-intIntCase\", func(t *testing.T) {\n\t\tm := NewCommonMap[int, int]()\n\t\tUnitTestFunc(m, &amp;intIntCase, t)\n\t})\n\tt.Run(\"test-stringStringCase\", func(t *testing.T) {\n\t\tm := NewCommonMap[string, string]()\n\t\tUnitTestFunc(m, &amp;stringStringCase, t)\n\t})\n\tt.Run(\"test-structStructCase\", func(t *testing.T) {\n\t\tm := NewCommonMap[testStruct, testStruct]()\n\t\tUnitTestFunc(m, &amp;structStructCase, t)\n\t})\n\tt.Run(\"test-intStructCase\", func(t *testing.T) {\n\t\tm := NewCommonMap[int, testStruct]()\n\t\tUnitTestFunc(m, &amp;intStructCase, t)\n\t})\n}\n\nfunc TestSimpleMap(t *testing.T) {\n\tt.Run(\"test-intIntCase\", func(t *testing.T) {\n\t\tm := NewSimpleMap[int, int]()\n\t\tUnitTestFunc(m, &amp;intIntCase, t)\n\t})\n\tt.Run(\"test-stringStringCase\", func(t *testing.T) {\n\t\tm := NewSimpleMap[string, string]()\n\t\tUnitTestFunc(m, &amp;stringStringCase, t)\n\t})\n\tt.Run(\"test-structStructCase\", func(t *testing.T) {\n\t\tm := NewSimpleMap[testStruct, testStruct]()\n\t\tUnitTestFunc(m, &amp;structStructCase, t)\n\t})\n\tt.Run(\"test-intStructCase\", func(t *testing.T) {\n\t\tm := NewSimpleMap[int, testStruct]()\n\t\tUnitTestFunc(m, &amp;intStructCase, t)\n\t})\n}\n\nfunc TestRWMap(t *testing.T) {\n\tt.Run(\"test-intIntCase\", func(t *testing.T) {\n\t\tm := NewRWMap[int, int](1)\n\t\tUnitTestFunc(m, &amp;intIntCase, t)\n\t})\n\tt.Run(\"test-stringStringCase\", func(t *testing.T) {\n\t\tm := NewRWMap[string, string](1)\n\t\tUnitTestFunc(m, &amp;stringStringCase, t)\n\t})\n\tt.Run(\"test-structStructCase\", func(t *testing.T) {\n\t\tm := NewRWMap[testStruct, testStruct](1)\n\t\tUnitTestFunc(m, &amp;structStructCase, t)\n\t})\n\tt.Run(\"test-intStructCase\", func(t *testing.T) {\n\t\tm := NewRWMap[int, testStruct](1)\n\t\tUnitTestFunc(m, &amp;intStructCase, t)\n\t})\n}\n\n单元测试用例\n点击展开以显示代码\nvar (\n\tintIntCase TestCase[int, int] = TestCase[int, int]{\n\t\tIndexes: []int{1, 2, 3},\n\t\tStoreKeys: map[int]int{\n\t\t\t1: 114514,\n\t\t\t2: 1919810,\n\t\t\t3: 2147,\n\t\t},\n\t\tStoreValues: map[int]int{\n\t\t\t1: 1919810,\n\t\t\t2: 114514,\n\t\t\t3: 65535,\n\t\t},\n\t\tDeleteKeys: map[int]int{\n\t\t\t1: 2147,\n\t\t\t2: 2147,\n\t\t\t3: 2147,\n\t\t},\n\t\tLoadKeys: map[int]int{\n\t\t\t1: 2147,\n\t\t\t2: 114514,\n\t\t\t3: 1919810,\n\t\t},\n\t\tWantLoaded: map[int]bool{\n\t\t\t1: false,\n\t\t\t2: true,\n\t\t\t3: true,\n\t\t},\n\t\tWantLoadValues: map[int]int{\n\t\t\t1: 0,\n\t\t\t2: 1919810,\n\t\t\t3: 114514,\n\t\t},\n\t\tRangeFunc: func(a, b int) bool {\n\t\t\tfmt.Printf(\"key: %d, value: %d\\n\", a, b)\n\t\t\treturn true\n\t\t},\n\t\tEquals: func(a, b int) bool {\n\t\t\treturn a == b\n\t\t},\n\t}\n\tstringStringCase TestCase[string, string] = TestCase[string, string]{\n\t\tIndexes: []int{1, 2, 3},\n\t\tStoreKeys: map[int]string{\n\t\t\t1: \"114514\",\n\t\t\t2: \"1919810\",\n\t\t\t3: \"2147\",\n\t\t},\n\t\tStoreValues: map[int]string{\n\t\t\t1: \"1919810\",\n\t\t\t2: \"114514\",\n\t\t\t3: \"65535\",\n\t\t},\n\t\tDeleteKeys: map[int]string{\n\t\t\t1: \"2147\",\n\t\t\t2: \"2147\",\n\t\t\t3: \"2147\",\n\t\t},\n\t\tLoadKeys: map[int]string{\n\t\t\t1: \"2147\",\n\t\t\t2: \"114514\",\n\t\t\t3: \"1919810\",\n\t\t},\n\t\tWantLoaded: map[int]bool{\n\t\t\t1: false,\n\t\t\t2: true,\n\t\t\t3: true,\n\t\t},\n\t\tWantLoadValues: map[int]string{\n\t\t\t1: \"\",\n\t\t\t2: \"1919810\",\n\t\t\t3: \"114514\",\n\t\t},\n\t\tRangeFunc: func(a, b string) bool {\n\t\t\tfmt.Printf(\"key: %v, value: %v\\n\", a, b)\n\t\t\treturn true\n\t\t},\n\t\tEquals: func(a, b string) bool {\n\t\t\treturn a == b\n\t\t},\n\t}\n\tintStructCase TestCase[int, testStruct] = TestCase[int, testStruct]{\n\t\tIndexes: []int{1, 2, 3},\n\t\tStoreKeys: map[int]int{\n\t\t\t1: 114514,\n\t\t\t2: 1919810,\n\t\t\t3: 2147,\n\t\t},\n\t\tStoreValues: map[int]testStruct{\n\t\t\t1: {val: 1919810},\n\t\t\t2: {val: 114514},\n\t\t\t3: {val: 65535},\n\t\t},\n\t\tDeleteKeys: map[int]int{\n\t\t\t1: 2147,\n\t\t\t2: 2147,\n\t\t\t3: 2147,\n\t\t},\n\t\tLoadKeys: map[int]int{\n\t\t\t1: 2147,\n\t\t\t2: 114514,\n\t\t\t3: 1919810,\n\t\t},\n\t\tWantLoaded: map[int]bool{\n\t\t\t1: false,\n\t\t\t2: true,\n\t\t\t3: true,\n\t\t},\n\t\tWantLoadValues: map[int]testStruct{\n\t\t\t1: {},\n\t\t\t2: {val: 1919810},\n\t\t\t3: {val: 114514},\n\t\t},\n\t\tRangeFunc: func(a int, b testStruct) bool {\n\t\t\tfmt.Printf(\"key: %d, value: %#v\\n\", a, b)\n\t\t\treturn true\n\t\t},\n\t\tEquals: func(a, b testStruct) bool {\n\t\t\treturn a.val == b.val\n\t\t},\n\t}\n\tstructStructCase TestCase[testStruct, testStruct] = TestCase[testStruct, testStruct]{\n\t\tIndexes: []int{1, 2, 3},\n\t\tStoreKeys: map[int]testStruct{\n\t\t\t1: {val: 114514},\n\t\t\t2: {val: 1919810},\n\t\t\t3: {val: 2147},\n\t\t},\n\t\tStoreValues: map[int]testStruct{\n\t\t\t1: {val: 1919810},\n\t\t\t2: {val: 114514},\n\t\t\t3: {val: 65535},\n\t\t},\n\t\tDeleteKeys: map[int]testStruct{\n\t\t\t1: {val: 2147},\n\t\t\t2: {val: 2147},\n\t\t\t3: {val: 2147},\n\t\t},\n\t\tLoadKeys: map[int]testStruct{\n\t\t\t1: {val: 2147},\n\t\t\t2: {val: 114514},\n\t\t\t3: {val: 1919810},\n\t\t},\n\t\tWantLoaded: map[int]bool{\n\t\t\t1: false,\n\t\t\t2: true,\n\t\t\t3: true,\n\t\t},\n\t\tWantLoadValues: map[int]testStruct{\n\t\t\t1: {},\n\t\t\t2: {val: 1919810},\n\t\t\t3: {val: 114514},\n\t\t},\n\t\tRangeFunc: func(a, b testStruct) bool {\n\t\t\tfmt.Printf(\"key: %#v, value: %#v\\n\", a, b)\n\t\t\treturn true\n\t\t},\n\t\tEquals: func(a, b testStruct) bool {\n\t\t\treturn a.val == b.val\n\t\t},\n\t}\n)\n\n\n单元测试结果\n点击展开以显示结果\n=== RUN   TestCommonMap\n=== RUN   TestCommonMap/test-intIntCase\nkey: 1919810, value: 114514\nkey: 114514, value: 1919810\n=== RUN   TestCommonMap/test-stringStringCase\nkey: 114514, value: 1919810\nkey: 1919810, value: 114514\n=== RUN   TestCommonMap/test-structStructCase\nkey: toy_kv.testStruct{val:114514}, value: toy_kv.testStruct{val:1919810}\nkey: toy_kv.testStruct{val:1919810}, value: toy_kv.testStruct{val:114514}\n=== RUN   TestCommonMap/test-intStructCase\nkey: 114514, value: toy_kv.testStruct{val:1919810}\nkey: 1919810, value: toy_kv.testStruct{val:114514}\n--- PASS: TestCommonMap (0.00s)\n    --- PASS: TestCommonMap/test-intIntCase (0.00s)\n    --- PASS: TestCommonMap/test-stringStringCase (0.00s)\n    --- PASS: TestCommonMap/test-structStructCase (0.00s)\n    --- PASS: TestCommonMap/test-intStructCase (0.00s)\n=== RUN   TestSimpleMap\n=== RUN   TestSimpleMap/test-intIntCase\nkey: 1919810, value: 114514\nkey: 114514, value: 1919810\n=== RUN   TestSimpleMap/test-stringStringCase\nkey: 114514, value: 1919810\nkey: 1919810, value: 114514\n=== RUN   TestSimpleMap/test-structStructCase\nkey: toy_kv.testStruct{val:114514}, value: toy_kv.testStruct{val:1919810}\nkey: toy_kv.testStruct{val:1919810}, value: toy_kv.testStruct{val:114514}\n=== RUN   TestSimpleMap/test-intStructCase\nkey: 114514, value: toy_kv.testStruct{val:1919810}\nkey: 1919810, value: toy_kv.testStruct{val:114514}\n--- PASS: TestSimpleMap (0.00s)\n    --- PASS: TestSimpleMap/test-intIntCase (0.00s)\n    --- PASS: TestSimpleMap/test-stringStringCase (0.00s)\n    --- PASS: TestSimpleMap/test-structStructCase (0.00s)\n    --- PASS: TestSimpleMap/test-intStructCase (0.00s)\n=== RUN   TestRWMap\n=== RUN   TestRWMap/test-intIntCase\nkey: 1919810, value: 114514\nkey: 114514, value: 1919810\n=== RUN   TestRWMap/test-stringStringCase\nkey: 114514, value: 1919810\nkey: 1919810, value: 114514\n=== RUN   TestRWMap/test-structStructCase\nkey: toy_kv.testStruct{val:114514}, value: toy_kv.testStruct{val:1919810}\nkey: toy_kv.testStruct{val:1919810}, value: toy_kv.testStruct{val:114514}\n=== RUN   TestRWMap/test-intStructCase\nkey: 114514, value: toy_kv.testStruct{val:1919810}\nkey: 1919810, value: toy_kv.testStruct{val:114514}\n--- PASS: TestRWMap (0.00s)\n    --- PASS: TestRWMap/test-intIntCase (0.00s)\n    --- PASS: TestRWMap/test-stringStringCase (0.00s)\n    --- PASS: TestRWMap/test-structStructCase (0.00s)\n    --- PASS: TestRWMap/test-intStructCase (0.00s)\nPASS\n\n\n基准测试基准测试函数// MapBenchmarkTestFunc 各种IMap的基准测试函数体\nfunc MapBenchmarkTestFunc(m IMap[int, int], goroutines, operations int, b *testing.B) {\n\tfor i := 0; i &lt; b.N; i++ {\n\t\twg := &amp;sync.WaitGroup{}\n\t\twg.Add(goroutines * operations)\n\t\tfor j := 0; j &lt; goroutines; j++ {\n\t\t\tgo func(index int) {\n\t\t\t\tfor k := 0; k &lt; operations; k++ {\n\t\t\t\t\tm.Store(index*operations+k, k)\n\t\t\t\t\tm.Load(index*operations + k)\n\t\t\t\t\twg.Done()\n\t\t\t\t}\n\t\t\t}(j)\n\t\t}\n\t\twg.Wait()\n\t}\n}\n\n基准测试内容// BenchmarkCommonMapTest 测试CommonMap进行100万次读和写的基准性能\nfunc BenchmarkCommonMapTest(b *testing.B) {\n\tm := NewCommonMap[int, int]()\n\tMapBenchmarkTestFunc(m, 100, 10000, b)\n}\n\n// BenchmarkSimpleMapTest 测试SimpleMap进行100万次读和写的基准性能\nfunc BenchmarkSimpleMapTest(b *testing.B) {\n\tm := NewSimpleMap[int, int]()\n\tMapBenchmarkTestFunc(m, 100, 10000, b)\n}\n\n// BenchmarkRWMapTest 测试RWMap进行100万次读和写的基准性能\nfunc BenchmarkRWMapTest(b *testing.B) {\n\tm := NewRWMap[int, int](10007)\n\tMapBenchmarkTestFunc(m, 100, 10000, b)\n}\n\n基准测试结果\n\n\n\n\n\n\n\n\n由于我们使用了统一的测试函数，通过这个函数来进行调用，会产生额外的(常数级)性能开销，实际使用时的性能比本测试结果高\n\n\n\n测试次数\n测试名称\n基准性能\n估算\n测试结果\n\n\n\n1\nBenchmarkCommonMapTest\n493900208 ns/op\n百万级吞吐量\nPASS\n\n\n1\nBenchmarkSimpleMapTest\n317186708 ns/op\n百万级吞吐量\nPASS\n\n\n1\nBenchmarkRWMapTest\n87778174 ns/op\n千万级吞吐量\nPASS\n\n\n2\nBenchmarkCommonMapTest\n520827944 ns/op\n百万级吞吐量\nPASS\n\n\n2\nBenchmarkSimpleMapTest\n302985188 ns/op\n百万级吞吐量\nPASS\n\n\n2\nBenchmarkRWMapTest\n81960308 ns/op\n千万级吞吐量\nPASS\n\n\n3\nBenchmarkCommonMapTest\n575636938 ns/op\n百万级吞吐量\nPASS\n\n\n3\nBenchmarkSimpleMapTest\n301984916 ns/op\n百万级吞吐量\nPASS\n\n\n3\nBenchmarkRWMapTest\n82087205 ns/op\n千万级吞吐量\nPASS\n\n\n视频教程\n.bili-div {\n    position: relative;\n    overflow: hidden;\n    padding-top: 56.25%;\n}\n\n.bili-player {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    border: 0;\n}\n\n\nIntroduction视频地址: [Go] 从零开始实现一个每秒千万级操作的Key-Value存储 - Introduction\n\n     \n\n\nCommonMap视频地址: [Go] 从零开始实现一个每秒千万级操作的Key-Value存储 - CommonMap\n\n     \n\n\nSimpleMap视频地址: [Go] 从零开始实现一个每秒千万级操作的Key-Value存储 - SimpleMap\n\n     \n\n\nRWMap视频地址: [Go] 从零开始实现一个每秒千万级操作的Key-Value存储 - RWMap\n\n     \n\n\n参考资料\nHash Functions in Go - James Smith\n\n","slug":"KeyValueStore-GolangImplement-3","date":"2022-08-15T01:53:46.000Z","categories_index":"blog","tags_index":"Golang,Redis,KeyValue","author_index":"𝚂𝚞𝚗𝚒𝚜𝚝𝙲"},{"id":"47859f6ed3b9b77bc9f9046f0cd4ce8c","title":"(第二弹)使用Golang实现一个并发安全的Map","content":"\n\n\n\n\n\n\n\n\n上回说到，用Golang实现了一个高性能的kv，但是由于锁的关系，即使有多个go程并发对kv进行操作，但还是会因为全局的锁导致一go干活，多go看戏的场面，今天就来优化一下这个kv，让它实现真正的并发干活\n思路总体设计思路还是没有变滴，我们还是要用上次那个模型进行总体设计，但是我们引入了一个新的机制：将dirty数据分散存储到若干个map里，这样锁就只会锁住单个map，其余的map还是可以进行读写操作的，通过这样来让多go程真正地并发工作\n总体结构图：\n\n读写流程图：\n\n\n\n\n\n\n\n\n\n\n先拿上次的图顶个数，下次更新再把图放上来，总体也差不多\n实现相对于上次的实现，我们引入了更多的文件：\n.\n|-- buff.go         // 缓冲channel相关实现\n|-- db.go           // kv主体实现\n|-- db_test.go      // 测试文件\n|-- dirty.go        // dirtyMap与实际存储的entity的实现\n|-- error.go        // 自定义错误\n`-- operator.go     // 具体操作kv的实现\n\nbuff.gopackage kv\n\ntype typeRequest int\n\nconst (\n\tgetValue typeRequest = iota\n\tsetValue\n\tdeleteKey\n\trangeDB\n)\n\ntype typeResponse int\n\nconst (\n\twithError typeResponse = iota\n\twithValue\n)\n\ntype requestFields int\n\nconst (\n\trequestKey requestFields = iota\n\trequestValue\n\trequestTimeout\n\trequestFunc\n)\n\ntype responseFields int\n\nconst (\n\tresponseKey responseFields = iota\n\tresponseValue\n\tresponseTimeout\n\tresponseError\n)\n\ntype dbRequest struct &#123;\n\trequestType typeRequest\n\targs        map[requestFields]interface&#123;&#125;\n\tcallback    chan dbResponse\n&#125;\n\ntype dbResponse struct &#123;\n\tresponseType typeResponse\n\treturns      map[responseFields]interface&#123;&#125;\n&#125;\n\nfunc newDbRequest(rType typeRequest) *dbRequest &#123;\n\treturn &amp;dbRequest&#123;\n\t\trequestType: rType,\n\t\targs:        make(map[requestFields]interface&#123;&#125;),\n\t\tcallback:    make(chan dbResponse, 1),\n\t&#125;\n&#125;\n\ndb.gopackage kv\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\ntype IDatabase interface &#123;\n\tGet(key interface&#123;&#125;) (value interface&#123;&#125;, timeout time.Duration, err error)\n\tSet(key interface&#123;&#125;, value interface&#123;&#125;, timeout time.Duration) (v interface&#123;&#125;, t time.Duration, e error)\n\tDelete(key interface&#123;&#125;) (ok bool, err error)\n\tRange(f func(key, value interface&#123;&#125;))\n\tClose()\n&#125;\n\nfunc NewDatabase(workers, buffSize, dirtyCount uint, hash func(key interface&#123;&#125;) uint) IDatabase &#123;\n\t// init kv-database\n\tdb := &amp;database&#123;\n\t\tbuff:    make(chan *dbRequest, buffSize),\n\t\texit:    make(chan struct&#123;&#125;, 1),\n\t\tdata:    make(map[uint]*dirtyMap, dirtyCount),\n\t\tsize:    dirtyCount,\n\t\tworkers: workers,\n\t\thash:    hash,\n\t&#125;\n\n\t// init dirty-map\n\tfor i := uint(0); i &lt; dirtyCount; i++ &#123;\n\t\tdb.data[i] = &amp;dirtyMap&#123;\n\t\t\tlock:  sync.RWMutex&#123;&#125;,\n\t\t\tdirty: make(map[interface&#123;&#125;]*entity),\n\t\t&#125;\n\t&#125;\n\n\t// start up operators\n\tdb.operator()\n\treturn db\n&#125;\n\ntype database struct &#123;\n\tsize    uint\n\tworkers uint\n\tbuff    chan *dbRequest\n\texit    chan struct&#123;&#125;\n\tdata    map[uint]*dirtyMap\n\thash    func(interface&#123;&#125;) uint\n&#125;\n\nfunc (d *database) Get(key interface&#123;&#125;) (value interface&#123;&#125;, timeout time.Duration, err error) &#123;\n\treq := newDbRequest(getValue)\n\tdefer close(req.callback)\n\treq.args = map[requestFields]interface&#123;&#125;&#123;\n\t\trequestKey: key,\n\t&#125;\n\td.buff &lt;- req\n\n\tresp := &lt;-req.callback\n\tswitch resp.responseType &#123;\n\tcase withError:\n\t\terr := resp.returns[responseError].(error)\n\t\treturn nil, time.Duration(0), err\n\tdefault:\n\t\treturn resp.returns[responseValue], resp.returns[responseTimeout].(time.Duration), nil\n\t&#125;\n&#125;\n\nfunc (d *database) Set(key interface&#123;&#125;, value interface&#123;&#125;, timeout time.Duration) (v interface&#123;&#125;, t time.Duration, e error) &#123;\n\treq := newDbRequest(setValue)\n\tdefer close(req.callback)\n\treq.args = map[requestFields]interface&#123;&#125;&#123;\n\t\trequestKey:     key,\n\t\trequestValue:   value,\n\t\trequestTimeout: timeout,\n\t&#125;\n\td.buff &lt;- req\n\n\tresp := &lt;-req.callback\n\tswitch resp.responseType &#123;\n\tcase withError:\n\t\terr := resp.returns[responseError].(error)\n\t\treturn nil, time.Duration(0), err\n\tdefault:\n\t\treturn resp.returns[responseValue], resp.returns[responseTimeout].(time.Duration), nil\n\t&#125;\n&#125;\n\nfunc (d *database) Delete(key interface&#123;&#125;) (ok bool, err error) &#123;\n\treq := newDbRequest(deleteKey)\n\tdefer close(req.callback)\n\treq.args = map[requestFields]interface&#123;&#125;&#123;\n\t\trequestKey: key,\n\t&#125;\n\td.buff &lt;- req\n\n\tresp := &lt;-req.callback\n\tswitch resp.responseType &#123;\n\tcase withError:\n\t\terr := resp.returns[responseError].(error)\n\t\treturn false, err\n\tdefault:\n\t\treturn true, nil\n\t&#125;\n&#125;\n\nfunc (d *database) Range(f func(key interface&#123;&#125;, value interface&#123;&#125;)) &#123;\n\treq := newDbRequest(rangeDB)\n\tdefer close(req.callback)\n\treq.args = map[requestFields]interface&#123;&#125;&#123;\n\t\trequestFunc: f,\n\t&#125;\n\td.buff &lt;- req\n\n\t&lt;-req.callback\n\treturn\n&#125;\n\nfunc (d *database) Close() &#123;\n\td.exit &lt;- struct&#123;&#125;&#123;&#125;\n&#125;\n\ndirty.gopackage kv\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\ntype entity struct &#123;\n\ttimeout time.Time\n\tdata    interface&#123;&#125;\n&#125;\n\ntype dirtyMap struct &#123;\n\tlock  sync.RWMutex\n\tdirty map[interface&#123;&#125;]*entity\n&#125;\n\nerror.gopackage kv\n\nimport \"fmt\"\n\ntype outOfRangeError struct &#123;\n\tupperIndex int\n\tlowerIndex int\n&#125;\n\nfunc (o outOfRangeError) Error() string &#123;\n\treturn fmt.Sprintf(\"kv-db out of range with [%v:%v]\", o.lowerIndex, o.upperIndex)\n&#125;\n\ntype notFoundError struct &#123;\n\tkey interface&#123;&#125;\n&#125;\n\nfunc (n notFoundError) Error() string &#123;\n\treturn fmt.Sprintf(\"kv-db cannot find key: %#v\", n.key)\n&#125;\n\noperator.gopackage kv\n\nimport (\n\t\"time\"\n)\n\nfunc (d *database) operator() &#123;\n\t// start up exit listener\n\texitChan := make(chan struct&#123;&#125;, d.workers)\n\tgo listenExitChan(d.exit, exitChan, d.workers)\n\n\t// start up operators\n\tfor i := uint(0); i &lt; d.workers; i++ &#123;\n\t\tgo startupOperator(d, exitChan)\n\t&#125;\n&#125;\n\nfunc listenExitChan(from, to chan struct&#123;&#125;, workers uint) &#123;\n\tselect &#123;\n\tcase &lt;-from:\n\t\tfor i := uint(0); i &lt; workers; i++ &#123;\n\t\t\tto &lt;- struct&#123;&#125;&#123;&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nfunc startupOperator(d *database, e chan struct&#123;&#125;) &#123;\n\tfor &#123;\n\t\tselect &#123;\n\t\tcase request := &lt;-d.buff:\n\t\t\tswitch request.requestType &#123;\n\t\t\tcase getValue:\n\t\t\t\trequest.callback &lt;- getValueOperate(d, request.args[requestKey])\n\t\t\tcase setValue:\n\t\t\t\trequest.callback &lt;- setValueOperate(d, request.args[requestKey], request.args[requestValue], request.args[requestTimeout].(time.Duration))\n\t\t\tcase deleteKey:\n\t\t\t\trequest.callback &lt;- deleteKeyOperate(d, request.args[requestKey])\n\t\t\tcase rangeDB:\n\t\t\t\trequest.callback &lt;- rangeDbOperate(d, request.args[requestFunc].(func(interface&#123;&#125;, interface&#123;&#125;)))\n\t\t\t&#125;\n\t\tcase &lt;-e:\n\t\t\treturn\n\t\t&#125;\n\t&#125;\n&#125;\n\nfunc getValueOperate(d *database, key interface&#123;&#125;) (resp dbResponse) &#123;\n\t// get dirty-map index and set read-lock\n\tindex := d.hash(key) % d.size\n\t_map := d.data[index]\n\t_map.lock.RLock()\n\tdefer _map.lock.RUnlock()\n\n\tif v, ok := _map.dirty[key]; !ok &#123;\n\t\t// condition: cannot find key in dirty-map\n\t\t// return error\n\t\tresp = dbResponse&#123;\n\t\t\tresponseType: withError,\n\t\t\treturns: map[responseFields]interface&#123;&#125;&#123;\n\t\t\t\tresponseError: notFoundError&#123;key: key&#125;,\n\t\t\t&#125;,\n\t\t&#125;\n\t&#125; else &#123;\n\t\t// condition: get entity succeed in dirty-map\n\t\tif v.timeout.Before(time.Now()) &#123;\n\t\t\t// condition: key-value pair timeout\n\t\t\t// delete key-value pair\n\t\t\t_map.lock.Lock()\n\t\t\tdefer _map.lock.Unlock()\n\t\t\tdelete(_map.dirty, key)\n\n\t\t\t// return error\n\t\t\tresp = dbResponse&#123;\n\t\t\t\tresponseType: withError,\n\t\t\t\treturns: map[responseFields]interface&#123;&#125;&#123;\n\t\t\t\t\tresponseError: notFoundError&#123;key: key&#125;,\n\t\t\t\t&#125;,\n\t\t\t&#125;\n\t\t&#125; else &#123;\n\t\t\t// condition: key-value pair not timeout\n\t\t\t// return value\n\t\t\tresp = dbResponse&#123;\n\t\t\t\tresponseType: withValue,\n\t\t\t\treturns: map[responseFields]interface&#123;&#125;&#123;\n\t\t\t\t\tresponseValue:   v.data,\n\t\t\t\t\tresponseTimeout: v.timeout.Sub(time.Now()),\n\t\t\t\t&#125;,\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\treturn resp\n&#125;\n\nfunc setValueOperate(d *database, key, value interface&#123;&#125;, timeout time.Duration) (resp dbResponse) &#123;\n\t// get dirty-map index and set write-lock\n\tindex := d.hash(key) % d.size\n\t_map := d.data[index]\n\t_map.lock.Lock()\n\tdefer _map.lock.Unlock()\n\n\t// update dirty-map\n\tv := &amp;entity&#123;\n\t\ttimeout: time.Now().Add(timeout),\n\t\tdata:    value,\n\t&#125;\n\t_map.dirty[key] = v\n\n\t// return value\n\tresp = dbResponse&#123;\n\t\tresponseType: withValue,\n\t\treturns: map[responseFields]interface&#123;&#125;&#123;\n\t\t\tresponseValue:   v.data,\n\t\t\tresponseTimeout: v.timeout.Sub(time.Now()),\n\t\t&#125;,\n\t&#125;\n\n\treturn resp\n&#125;\n\nfunc deleteKeyOperate(d *database, key interface&#123;&#125;) (resp dbResponse) &#123;\n\t// get dirty-map index and set read-lock\n\tindex := d.hash(key) % d.size\n\t_map := d.data[index]\n\t_map.lock.RLock()\n\tdefer _map.lock.RUnlock()\n\n\tif _, ok := _map.dirty[key]; !ok &#123;\n\t\t// condition: cannot find key in dirty-map\n\t\t// return value\n\t\tresp = dbResponse&#123;\n\t\t\tresponseType: withValue,\n\t\t\treturns:      nil,\n\t\t&#125;\n\t&#125; else &#123;\n\t\t// delete key-value pair\n\t\t_map.lock.Lock()\n\t\tdefer _map.lock.Unlock()\n\t\tdelete(_map.dirty, key)\n\n\t\t// return value\n\t\tresp = dbResponse&#123;\n\t\t\tresponseType: withValue,\n\t\t\treturns:      nil,\n\t\t&#125;\n\t&#125;\n\n\treturn resp\n&#125;\n\nfunc rangeDbOperate(d *database, f func(key, value interface&#123;&#125;)) (resp dbResponse) &#123;\n\tfor i := uint(0); i &lt; d.size; i++ &#123;\n\t\t// set write-lock\n\t\tcurrent := d.data[i]\n\t\tcurrent.lock.Lock()\n\n\t\t// execute function\n\t\tfor k, v := range current.dirty &#123;\n\t\t\tf(k, v.data)\n\t\t&#125;\n\t\tcurrent.lock.Unlock()\n\t&#125;\n\n\t// return value\n\tresp = dbResponse&#123;\n\t\tresponseType: withValue,\n\t\treturns:      nil,\n\t&#125;\n\n\treturn resp\n&#125;\n\n测试经测试，多go程的情况下，进行一千万次读写所用的总时间为8.6s，比上次进行的单go程性能更优\n","slug":"KeyValueStore-GolangImplement-2","date":"2022-07-21T07:39:53.000Z","categories_index":"blog","tags_index":"Golang,Redis,KeyValue","author_index":"𝚂𝚞𝚗𝚒𝚜𝚝𝙲"},{"id":"9d5491a5ddb5a138c7973036a7b8ad61","title":"使用Golang实现一个并发安全的Map","content":"\n\n\n\n\n\n\n\n\n这篇博文是CeobeBot的框架CeobeBotFramework的kv部分的总结\n总说redis单线程性能高，最近正好在实现自拟的框架，于是产生了一个用golang实现一个高性能kv的想法，进行了一天的coding、单元测试和基准测试以后，得出的结论是：\n\n有锁的并发kv性能低于无锁的kv\n\n思路先贴一下定义结构的代码：\ntype IDatabase interface &#123;\n\tGet(key interface&#123;&#125;) (value interface&#123;&#125;, timeout time.Duration, err error)\n\tSet(key interface&#123;&#125;, value interface&#123;&#125;, timeout time.Duration) (v interface&#123;&#125;, t time.Duration, e error)\n\tDelete(key interface&#123;&#125;) (ok bool, err error)\n\tRange(f func(key, value interface&#123;&#125;))\n\tClose()\n&#125;\n\ntype database struct &#123;\n\tmu    sync.RWMutex\n\tbuff  chan *dbRequest\n\texit  chan struct&#123;&#125;\n\tdirty map[interface&#123;&#125;]*entity\n&#125;\n\n相信大家看到这里都已经知道了我的思路：就是用一个chanel作为kv的命令缓冲区，保证kv的并发安全性，然后使用go routine作为consumer消费这个chanel里的指令，至于那个锁mu sync.RWMutex呢，则是为进行并发读写的实现方式准备的\n整个结构图如下：\n\n读写过程如下图：\n\n实现首先要说明的是项目的结构：\n.\n|-- buff.go         // 缓冲chanel相关的结构体\n|-- db.go           // kv主体实现\n|-- db_test.go      // 测试文件\n|-- entity.go       // kv实际存储内容\n`-- error.go        // 自定义错误\n\ndb.gopackage kv\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\ntype IDatabase interface &#123;\n\tGet(key interface&#123;&#125;) (value interface&#123;&#125;, timeout time.Duration, err error)\n\tSet(key interface&#123;&#125;, value interface&#123;&#125;, timeout time.Duration) (v interface&#123;&#125;, t time.Duration, e error)\n\tDelete(key interface&#123;&#125;) (ok bool, err error)\n\tRange(f func(key, value interface&#123;&#125;))\n\tClose()\n&#125;\n\nfunc NewDatabase(workers, buffSize int) IDatabase &#123;\n\tdb := &amp;database&#123;\n\t\tbuff:  make(chan *dbRequest, buffSize),\n\t\texit:  make(chan struct&#123;&#125;, 1),\n\t\tdirty: make(map[interface&#123;&#125;]*entity),\n\t\tmu:    sync.RWMutex&#123;&#125;,\n\t&#125;\n\tdb.operator(workers)\n\treturn db\n&#125;\n\ntype database struct &#123;\n\tmu    sync.RWMutex\n\tbuff  chan *dbRequest\n\texit  chan struct&#123;&#125;\n\tdirty map[interface&#123;&#125;]*entity\n&#125;\n\nfunc (d database) Get(key interface&#123;&#125;) (value interface&#123;&#125;, timeout time.Duration, err error) &#123;\n\treq := newDbRequest(getValue)\n\tdefer close(req.callback)\n\treq.args = map[requestFields]interface&#123;&#125;&#123;\n\t\trequestKey: key,\n\t&#125;\n\td.buff &lt;- req\n\n\tresp := &lt;-req.callback\n\tswitch resp.responseType &#123;\n\tcase withError:\n\t\terr := resp.returns[responseError].(error)\n\t\treturn nil, time.Duration(0), err\n\tdefault:\n\t\tvalue := resp.returns[responseValue]\n\t\ttimeout := resp.returns[responseTimeout].(time.Time)\n\t\tout := timeout.Sub(time.Now())\n\t\treturn value, out, nil\n\t&#125;\n&#125;\n\nfunc (d database) Set(key interface&#123;&#125;, value interface&#123;&#125;, timeout time.Duration) (v interface&#123;&#125;, t time.Duration, e error) &#123;\n\treq := newDbRequest(setValue)\n\tdefer close(req.callback)\n\treq.args = map[requestFields]interface&#123;&#125;&#123;\n\t\trequestKey:     key,\n\t\trequestValue:   value,\n\t\trequestTimeout: time.Now().Add(timeout),\n\t&#125;\n\td.buff &lt;- req\n\n\tresp := &lt;-req.callback\n\tswitch resp.responseType &#123;\n\tcase withError:\n\t\terr := resp.returns[responseError].(error)\n\t\treturn nil, time.Duration(0), err\n\tdefault:\n\t\tvalue := resp.returns[responseValue]\n\t\ttimeout := resp.returns[responseTimeout].(time.Time)\n\t\tout := timeout.Sub(time.Now())\n\t\treturn value, out, nil\n\t&#125;\n&#125;\n\nfunc (d database) Delete(key interface&#123;&#125;) (ok bool, err error) &#123;\n\treq := newDbRequest(deleteKey)\n\tdefer close(req.callback)\n\treq.args = map[requestFields]interface&#123;&#125;&#123;\n\t\trequestKey: key,\n\t&#125;\n\td.buff &lt;- req\n\n\tresp := &lt;-req.callback\n\tswitch resp.responseType &#123;\n\tcase withError:\n\t\terr := resp.returns[responseError].(error)\n\t\treturn false, err\n\tdefault:\n\t\treturn true, nil\n\t&#125;\n&#125;\n\nfunc (d database) Range(f func(key interface&#123;&#125;, value interface&#123;&#125;)) &#123;\n\treq := newDbRequest(rangeDB)\n\tdefer close(req.callback)\n\treq.args = map[requestFields]interface&#123;&#125;&#123;\n\t\trequestFunc: f,\n\t&#125;\n\td.buff &lt;- req\n\n\t&lt;-req.callback\n\treturn\n&#125;\n\nfunc (d *database) operator(workers int) &#123;\n\tif workers == 1 &#123;\n\t\tgo func(d *database) &#123;\n\t\t\tfor &#123;\n\t\t\t\tselect &#123;\n\t\t\t\tcase request := &lt;-d.buff:\n\t\t\t\t\tswitch request.requestType &#123;\n\t\t\t\t\tcase getValue:\n\t\t\t\t\t\tkey := request.args[requestKey]\n\t\t\t\t\t\tif entity, ok := d.dirty[key]; !ok &#123;\n\t\t\t\t\t\t\tcallback := dbResponse&#123;\n\t\t\t\t\t\t\t\tresponseType: withError,\n\t\t\t\t\t\t\t\treturns: map[responseFields]interface&#123;&#125;&#123;\n\t\t\t\t\t\t\t\t\tresponseError: notFoundError&#123;key: key&#125;,\n\t\t\t\t\t\t\t\t&#125;,\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\trequest.callback &lt;- callback\n\t\t\t\t\t\t&#125; else &#123;\n\t\t\t\t\t\t\tif entity.timeout.Before(time.Now()) &#123;\n\t\t\t\t\t\t\t\tdelete(d.dirty, key)\n\t\t\t\t\t\t\t\tcallback := dbResponse&#123;\n\t\t\t\t\t\t\t\t\tresponseType: withError,\n\t\t\t\t\t\t\t\t\treturns: map[responseFields]interface&#123;&#125;&#123;\n\t\t\t\t\t\t\t\t\t\tresponseError: notFoundError&#123;key: key&#125;,\n\t\t\t\t\t\t\t\t\t&#125;,\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\trequest.callback &lt;- callback\n\t\t\t\t\t\t\t&#125; else &#123;\n\t\t\t\t\t\t\t\tcallback := dbResponse&#123;\n\t\t\t\t\t\t\t\t\tresponseType: withValue,\n\t\t\t\t\t\t\t\t\treturns: map[responseFields]interface&#123;&#125;&#123;\n\t\t\t\t\t\t\t\t\t\tresponseValue:   entity.data,\n\t\t\t\t\t\t\t\t\t\tresponseTimeout: entity.timeout,\n\t\t\t\t\t\t\t\t\t&#125;,\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\trequest.callback &lt;- callback\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t&#125;\n\t\t\t\t\tcase setValue:\n\t\t\t\t\t\tkey := request.args[requestKey]\n\t\t\t\t\t\tvalue := request.args[requestValue]\n\t\t\t\t\t\ttimeout := request.args[requestTimeout].(time.Time)\n\t\t\t\t\t\tentity := &amp;entity&#123;\n\t\t\t\t\t\t\ttimeout: timeout,\n\t\t\t\t\t\t\tdata:    value,\n\t\t\t\t\t\t\tmu:      sync.RWMutex&#123;&#125;,\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\td.dirty[key] = entity\n\n\t\t\t\t\t\tcallback := dbResponse&#123;\n\t\t\t\t\t\t\tresponseType: withValue,\n\t\t\t\t\t\t\treturns: map[responseFields]interface&#123;&#125;&#123;\n\t\t\t\t\t\t\t\tresponseValue:   entity.data,\n\t\t\t\t\t\t\t\tresponseTimeout: entity.timeout,\n\t\t\t\t\t\t\t&#125;,\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\trequest.callback &lt;- callback\n\t\t\t\t\tcase deleteKey:\n\t\t\t\t\t\tkey := request.args[requestKey]\n\t\t\t\t\t\tif _, ok := d.dirty[key]; ok &#123;\n\t\t\t\t\t\t\tdelete(d.dirty, key)\n\t\t\t\t\t\t\tcallback := dbResponse&#123;\n\t\t\t\t\t\t\t\tresponseType: withValue,\n\t\t\t\t\t\t\t\treturns:      nil,\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\trequest.callback &lt;- callback\n\t\t\t\t\t\t&#125; else &#123;\n\t\t\t\t\t\t\tcallback := dbResponse&#123;\n\t\t\t\t\t\t\t\tresponseType: withValue,\n\t\t\t\t\t\t\t\treturns:      nil,\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\trequest.callback &lt;- callback\n\t\t\t\t\t\t&#125;\n\t\t\t\t\tcase rangeDB:\n\t\t\t\t\t\tfunction := request.args[requestFunc].(func(key, value interface&#123;&#125;))\n\t\t\t\t\t\tfor i, e := range d.dirty &#123;\n\t\t\t\t\t\t\tfunction(i, e.data)\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\tcallback := dbResponse&#123;\n\t\t\t\t\t\t\tresponseType: withValue,\n\t\t\t\t\t\t\treturns:      nil,\n\t\t\t\t\t\t&#125;\n\t\t\t\t\t\trequest.callback &lt;- callback\n\t\t\t\t\t&#125;\n\t\t\t\tcase &lt;-d.exit:\n\t\t\t\t\treturn\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;(d)\n\t&#125; else &#123;\n\t\texitChan := make(chan struct&#123;&#125;, workers)\n\t\tfor i := 0; i &lt; workers; i++ &#123;\n\t\t\tgo func(e chan struct&#123;&#125;, d *database) &#123;\n\t\t\t\tfor &#123;\n\t\t\t\t\tselect &#123;\n\t\t\t\t\tcase request := &lt;-d.buff:\n\t\t\t\t\t\tswitch request.requestType &#123;\n\t\t\t\t\t\tcase getValue:\n\t\t\t\t\t\t\td.mu.RLock()\n\t\t\t\t\t\t\tkey := request.args[requestKey]\n\t\t\t\t\t\t\tif entity, ok := d.dirty[key]; !ok &#123;\n\t\t\t\t\t\t\t\tcallback := dbResponse&#123;\n\t\t\t\t\t\t\t\t\tresponseType: withError,\n\t\t\t\t\t\t\t\t\treturns: map[responseFields]interface&#123;&#125;&#123;\n\t\t\t\t\t\t\t\t\t\tresponseError: notFoundError&#123;key: key&#125;,\n\t\t\t\t\t\t\t\t\t&#125;,\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\trequest.callback &lt;- callback\n\t\t\t\t\t\t\t&#125; else &#123;\n\t\t\t\t\t\t\t\tentity.read()\n\t\t\t\t\t\t\t\tif entity.timeout.Before(time.Now()) &#123;\n\t\t\t\t\t\t\t\t\tdelete(d.dirty, key)\n\t\t\t\t\t\t\t\t\tcallback := dbResponse&#123;\n\t\t\t\t\t\t\t\t\t\tresponseType: withError,\n\t\t\t\t\t\t\t\t\t\treturns: map[responseFields]interface&#123;&#125;&#123;\n\t\t\t\t\t\t\t\t\t\t\tresponseError: notFoundError&#123;key: key&#125;,\n\t\t\t\t\t\t\t\t\t\t&#125;,\n\t\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\t\trequest.callback &lt;- callback\n\t\t\t\t\t\t\t\t&#125; else &#123;\n\t\t\t\t\t\t\t\t\tcallback := dbResponse&#123;\n\t\t\t\t\t\t\t\t\t\tresponseType: withValue,\n\t\t\t\t\t\t\t\t\t\treturns: map[responseFields]interface&#123;&#125;&#123;\n\t\t\t\t\t\t\t\t\t\t\tresponseValue:   entity.data,\n\t\t\t\t\t\t\t\t\t\t\tresponseTimeout: entity.timeout,\n\t\t\t\t\t\t\t\t\t\t&#125;,\n\t\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\t\trequest.callback &lt;- callback\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\tentity.readDone()\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\td.mu.RUnlock()\n\t\t\t\t\t\tcase setValue:\n\t\t\t\t\t\t\td.mu.Lock()\n\t\t\t\t\t\t\tkey := request.args[requestKey]\n\t\t\t\t\t\t\tvalue := request.args[requestValue]\n\t\t\t\t\t\t\ttimeout := request.args[requestTimeout].(time.Time)\n\t\t\t\t\t\t\tentity := &amp;entity&#123;\n\t\t\t\t\t\t\t\ttimeout: timeout,\n\t\t\t\t\t\t\t\tdata:    value,\n\t\t\t\t\t\t\t\tmu:      sync.RWMutex&#123;&#125;,\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\tentity.write()\n\t\t\t\t\t\t\td.dirty[key] = entity\n\n\t\t\t\t\t\t\tcallback := dbResponse&#123;\n\t\t\t\t\t\t\t\tresponseType: withValue,\n\t\t\t\t\t\t\t\treturns: map[responseFields]interface&#123;&#125;&#123;\n\t\t\t\t\t\t\t\t\tresponseValue:   entity.data,\n\t\t\t\t\t\t\t\t\tresponseTimeout: entity.timeout,\n\t\t\t\t\t\t\t\t&#125;,\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\tentity.writeDone()\n\t\t\t\t\t\t\trequest.callback &lt;- callback\n\t\t\t\t\t\t\td.mu.Unlock()\n\t\t\t\t\t\tcase deleteKey:\n\t\t\t\t\t\t\td.mu.Lock()\n\t\t\t\t\t\t\tkey := request.args[requestKey]\n\t\t\t\t\t\t\tif e, ok := d.dirty[key]; ok &#123;\n\t\t\t\t\t\t\t\te.write()\n\t\t\t\t\t\t\t\tdelete(d.dirty, key)\n\t\t\t\t\t\t\t\tcallback := dbResponse&#123;\n\t\t\t\t\t\t\t\t\tresponseType: withValue,\n\t\t\t\t\t\t\t\t\treturns:      nil,\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\trequest.callback &lt;- callback\n\t\t\t\t\t\t\t&#125; else &#123;\n\t\t\t\t\t\t\t\tcallback := dbResponse&#123;\n\t\t\t\t\t\t\t\t\tresponseType: withValue,\n\t\t\t\t\t\t\t\t\treturns:      nil,\n\t\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\t\trequest.callback &lt;- callback\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\td.mu.Unlock()\n\t\t\t\t\t\tcase rangeDB:\n\t\t\t\t\t\t\td.mu.Lock()\n\t\t\t\t\t\t\tfunction := request.args[requestFunc].(func(key, value interface&#123;&#125;))\n\t\t\t\t\t\t\tfor i, e := range d.dirty &#123;\n\t\t\t\t\t\t\t\te.write()\n\t\t\t\t\t\t\t\tfunction(i, e.data)\n\t\t\t\t\t\t\t\te.writeDone()\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\tcallback := dbResponse&#123;\n\t\t\t\t\t\t\t\tresponseType: withValue,\n\t\t\t\t\t\t\t\treturns:      nil,\n\t\t\t\t\t\t\t&#125;\n\t\t\t\t\t\t\trequest.callback &lt;- callback\n\t\t\t\t\t\t\td.mu.Unlock()\n\t\t\t\t\t\t&#125;\n\t\t\t\t\tcase &lt;-exitChan:\n\t\t\t\t\t\treturn\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;(exitChan, d)\n\t\t&#125;\n\t\tgo func(e chan struct&#123;&#125;, d *database, w int) &#123;\n\t\t\tselect &#123;\n\t\t\tcase &lt;-d.exit:\n\t\t\t\tfor i := 0; i &lt; w; i++ &#123;\n\t\t\t\t\te &lt;- struct&#123;&#125;&#123;&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;(exitChan, d, workers)\n\t&#125;\n\n&#125;\n\nfunc (d database) Close() &#123;\n\td.exit &lt;- struct&#123;&#125;&#123;&#125;\n&#125;\n\nentity.gopackage kv\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\ntype entity struct &#123;\n\tmu      sync.RWMutex\n\ttimeout time.Time\n\tdata    interface&#123;&#125;\n&#125;\n\nfunc (e *entity) write() &#123;\n\te.mu.Lock()\n&#125;\n\nfunc (e *entity) writeDone() &#123;\n\te.mu.Unlock()\n&#125;\n\nfunc (e *entity) read() &#123;\n\te.mu.RLock()\n&#125;\n\nfunc (e *entity) readDone() &#123;\n\te.mu.RUnlock()\n&#125;\n\nbuff.gopackage kv\n\ntype typeRequest int\n\nconst (\n\tgetValue typeRequest = iota\n\tsetValue\n\tdeleteKey\n\trangeDB\n)\n\ntype typeResponse int\n\nconst (\n\twithError typeResponse = iota\n\twithValue\n)\n\ntype requestFields int\n\nconst (\n\trequestKey requestFields = iota\n\trequestValue\n\trequestTimeout\n\trequestFunc\n)\n\ntype responseFields int\n\nconst (\n\tresponseKey responseFields = iota\n\tresponseValue\n\tresponseTimeout\n\tresponseError\n)\n\ntype dbRequest struct &#123;\n\trequestType typeRequest\n\targs        map[requestFields]interface&#123;&#125;\n\tcallback    chan dbResponse\n&#125;\n\ntype dbResponse struct &#123;\n\tresponseType typeResponse\n\treturns      map[responseFields]interface&#123;&#125;\n&#125;\n\nfunc newDbRequest(rType typeRequest) *dbRequest &#123;\n\treturn &amp;dbRequest&#123;\n\t\trequestType: rType,\n\t\targs:        make(map[requestFields]interface&#123;&#125;),\n\t\tcallback:    make(chan dbResponse, 1),\n\t&#125;\n&#125;\n\nerror.gopackage kv\n\nimport \"fmt\"\n\ntype outOfRangeError struct &#123;\n\tupperIndex int\n\tlowerIndex int\n&#125;\n\nfunc (o outOfRangeError) Error() string &#123;\n\treturn fmt.Sprintf(\"kv-db out of range with [%v:%v]\", o.lowerIndex, o.upperIndex)\n&#125;\n\ntype notFoundError struct &#123;\n\tkey interface&#123;&#125;\n&#125;\n\nfunc (n notFoundError) Error() string &#123;\n\treturn fmt.Sprintf(\"kv-db cannot find key: %#v\", n.key)\n&#125;\n\n测试测试文件下面的各种情况的测试均在本文件的基础下进行，区别是改了部分参数，单次operation均为十万次读&#x2F;写\npackage kv\n\nimport (\n\t\"math/rand\"\n\t\"testing\"\n\t\"time\"\n)\n\nvar (\n\tdb = NewDatabase(1, 1000)\n)\n\nfunc init() &#123;\n\tfor j := 0; j &lt; 10000; j++ &#123;\n\t\tdb.Set(rand.Int(), j, time.Second)\n\t&#125;\n&#125;\n\nfunc BenchmarkTest(b *testing.B) &#123;\n\n\tfor i := 0; i &lt; b.N; i++ &#123;\n\t\tfor j := 0; j &lt; 33333; j++ &#123;\n\t\t\tdb.Set(rand.Int(), j, time.Second)\n\t\t&#125;\n\t\tfor j := 0; j &lt; 33333; j++ &#123;\n\t\t\tdb.Delete(rand.Int())\n\t\t&#125;\n\t\tfor j := 0; j &lt; 33333; j++ &#123;\n\t\t\tdb.Get(rand.Int())\n\t\t&#125;\n\t&#125;\n&#125;\n\n纯读取测试goos: darwin\ngoarch: arm64\npkg: github.com/sunist-c/CeobeBotFramework/infrastructure/kv\nBenchmarkTest\nBenchmarkTest-8   \t      13\t  85523782 ns/op\nPASS\n\n纯写入测试goos: darwin\ngoarch: arm64\npkg: github.com/sunist-c/CeobeBotFramework/infrastructure/kv\nBenchmarkTest\nBenchmarkTest-8   \t       8\t 148629094 ns/op\nPASS\n\n读写混合测试goos: darwin\ngoarch: arm64\npkg: github.com/sunist-c/CeobeBotFramework/infrastructure/kv\nBenchmarkTest\nBenchmarkTest-8   \t      12\t 105071628 ns/op\nPASS\n\n多go程纯读取测试goos: darwin\ngoarch: arm64\npkg: github.com/sunist-c/CeobeBotFramework/infrastructure/kv\nBenchmarkTest\nBenchmarkTest-8   \t      13\t  85009984 ns/op\nPASS\n\n多go程纯写入测试goos: darwin\ngoarch: arm64\npkg: github.com/sunist-c/CeobeBotFramework/infrastructure/kv\nBenchmarkTest\nBenchmarkTest-8   \t       8\t 150155224 ns/op\nPASS\n\n多go程读写混合测试goos: darwin\ngoarch: arm64\npkg: github.com/sunist-c/CeobeBotFramework/infrastructure/kv\nBenchmarkTest\nBenchmarkTest-8   \t      12\t 106118806 ns/op\nPASS\n\n在基准测试中，由于测试是顺序进行的，没有进行并发处理，我们后面加上了并发的测试：\n\n\n\n项目\n耗时\n测试量\n\n\n\n单go程均衡测试\n647.506166ms\n100go程，每go程万次读&#x2F;写\n\n\n多go程均衡测试\n784.627083ms\n100go程，每go程万次读&#x2F;写\n\n\n单go程均衡测试\n8.808718542s\n1000go程，每go程万次读&#x2F;写\n\n\n多go程均衡测试\n11.675095125s\n1000go程，每go程万次读&#x2F;写\n\n\n可见，随着go程的增多，单go程的方式就越来越快\n总结本来做多go程worker的时候，是没有给dirty加锁的，后面报了panic，查阅了资料以后发现，map不是并发安全的地方表现就表现在，它不能并发地进行读写，原来还以为只是简单脏数据的问题…所以后面无奈加上了锁\n至于真·多go程实现，就需要等下次有空摸鱼的时候抛弃内建map进行一个重构了\n","slug":"KeyValueStore-GolangImplement","date":"2022-07-20T09:16:54.000Z","categories_index":"blog","tags_index":"Golang,Redis,KeyValue","author_index":"𝚂𝚞𝚗𝚒𝚜𝚝𝙲"},{"id":"e234e9c36130a19f52c8637c43f3ee43","title":"浅试golang泛型","content":"Golang 1.18正式支持了泛型，当时就想试一试，无奈Goland当时的版本不支持，最近才意识到2022年的Goland已经开始支持Golang的泛型了，遂进行一下小尝试，顺便做一下记录\nEnv\n\n\n\n\n\n\n\n\n操作系统: macOS Monterey Version12.4\nIDE: Goland 2021.3.4\nGoEnv: go 1.18.4 arm64\n泛型使用使用方法Golang的泛型声明方法和Java&#x2F;C++相差不大，其语法如下：\nfunc sort[T any](array []T, cmp func(T, T) bool) &#123;\n    // ...implements\n&#125;\n\ntype IList[T any] interface &#123;\n    // ...methods\n&#125;\n\ntype List[T any] struct &#123;\n    // ...fields\n&#125;\n\n完整示例下面的代码是简单实现的排序方法，懒就写了个简单的冒泡：\npackage main\n\nimport \"fmt\"\n\nfunc sort[T any](arr []T, cmp func(a, b T) bool) &#123;\n\tfmt.Printf(\"sorting array: %#v\\n\", arr)\n\tsorted := false\n\tfor i := 0; !sorted; i++ &#123;\n\t\tsorted = true\n\t\tfor j := i; j &lt; len(arr); j++ &#123;\n\t\t\tif cmp(arr[i], arr[j]) &#123;\n\t\t\t\tarr[i], arr[j] = arr[j], arr[i]\n\t\t\t\tsorted = false\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nfunc cmp(a, b int) bool &#123;\n\treturn a >= b\n&#125;\n\nfunc main() &#123;\n\tarr := []int&#123;1, 4, 5, 3, 2&#125;\n\tsort(arr, cmp)\n\tfmt.Printf(\"sorted array: %#v\\n\", arr)\n&#125;\n\n运行结果如下：\nsorting array: []int&#123;1, 4, 5, 3, 2&#125;\nsorted array: []int&#123;1, 2, 3, 4, 5&#125;\n\nProcess finished with the exit code 0\n\n注意事项虽然interface&#123;&#125;和struct&#123;&#125;可以被[T any]修饰，但是将[T any]修饰结构体的方法时，Goland则会报错：\nMethod cannot have type parameters\n\n并且用结构体实现带[T any]修饰的接口时，Goland自动生成实现时，会修改方法的参数类型，将T修改为interface&#123;&#125;：\n定义的接口：\ntype IList[T any] interface &#123;\n\tInsert(int, T)\n&#125;\n\n自动生成的实现：\nfunc (l List) Insert(i int, t interface&#123;&#125;) &#123;\n\t//TODO implement me\n\tpanic(\"implement me\")\n&#125;\n\n总结我也只是个刚入门go的小蒟蒻，总结可能不到位，民那桑看看就好\n\n第一眼看居然和template&lt;class T&gt;差不多，本来以为能够突破go针对不同类型代码复用状况，实际使用下来也只能在函数上下下功夫，基本等于静态方法的泛型\n本以为可以突破C&#x2F;C++运行时泛型的局限，因为go的泛型是在编译前就会提示错误的，但是结果go的泛型并不能挂在结构体也就是对象上使用，总体来说没有Java&#x2F;C#一类的强OOP语言舒服\n期待大佬们能够在go泛型的基础上封一些容器出来了，到时候就不用手写基础结构体了，直接调包……\n\n","slug":"Try-GolangGenerics","date":"2022-07-18T06:44:39.000Z","categories_index":"blog","tags_index":"Golang,OOP,Generics","author_index":"𝚂𝚞𝚗𝚒𝚜𝚝𝙲"},{"id":"a3fb736aa42338fc8e8d5d10993cc4eb","title":"ProjectAnalysis - 设计文档","content":"\n\n\n\n\n\n\n\n\n本blog是 SunistC 在学年设计期间，为了卷一个项目和小组同学一起拿高分，计划开发的基于大数据的分布式微服务系统，用于可视化展示全球的疫情状况，本文是设计阶段的记录，本文所对应的仓库为 ProjectAnalysis ，采用 MIT 协议\n1. 架构1.1 Overview\n1.2 Frontend - 展示数据\n使用Vue.js构建Web\n使用Echarts执行图形可视化\n使用Material作为UI框架\n\n1.3 Backend - 响应前端&#x2F;调起大数据服务\n使用go-gin构建http服务\n使用go-zero拆分微服务\n使用OAuth2.0进行客户端认证\n使用Kafka进行日志收集\n使用Redis和ClickHouse作为临时数据存储\n使用Mysql作为持久化数据存储\n使用cron定时处理scrapy爬虫任务\n\n1.4 Big Data - 大数据离线处理\n使用SpringRPC进行rpc调用\n使用Hive作为大数据离线处理工具\n使用Mysql作为持久化数据存储\n使用HBase作为数据仓库\n\n2. 功能点2.1 前端功能点Overview\n\n\n\n\n\n\n\n\n竞品参考： COVID-19 Map - Johns Hopkins Coronavirus Resource Center (jhu.edu)\n\n\n功能1: 地图可视化\n分为国际地图、国内地图、城市地图三个层级，每个层级分别可视化展示热力图或者散点图\n国际地图点击中国国界可以跳转到国内地图\n国内地图点击省份可以跳转到城市地图\n最高精度精确到城市&#x2F;区\n\n\n功能2: 图形可视化\n随地图可视化功能同步变化，用户可选展示信息\n可展示信息如下：\n当前区域每周死亡&#x2F;每周感染&#x2F;每周治愈病例\n当前区域每天死亡&#x2F;每天感染&#x2F;每天治愈病例\n\n\n\n\n功能3: TopN图表\n随地图可视化功能同步变化，用户可选展示信息\n可展示信息如下：\n当前区域感染TopN\n当前区域治愈TopN\n当前区域死亡TopN\n\n\n\n\n功能4: 当前区域信息展示\n随地图可视化功能同步变化，向用户展示以下信息：\n当前区域累计病例\n当前区域累计死亡\n当前区域累计治愈\n当前区域本月病例\n当前区域本月死亡\n当前区域本月治愈\n当前区域每日病例\n当前区域每日死亡\n当前区域每日治愈\n\n\n\n\n功能5: 当前区域新闻展示\n随地图可视化功能同步变化，向用户展示当前区域的疫情相关新闻与摘要\n\n\n\n2.2 后端功能点\n功能1: 基于OAuth2.0协议和JWT进行客户端验证与用户验证\n功能2: 基于Kafka进行日志收集和消息分发\n功能3: 基于gRPC协议和go-zero&#x2F;go-gin框架，提供http服务，并使用Docker构建微服务集群\n功能4: 基于scrapy和cron进行定期数据爬取数据，使用rpc调用大数据端进行离线数据处理\n功能5: 使用redis和ClickHouse进行数据缓存\n\n2.3 大数据端功能点\n功能1: 基于爬虫数据计算并更新地图数据\n\n3. 接口3.1 大数据端接口\nUpdateData: 更新特定区域的数据接口(grpc)\n\nsyntax = \"proto3\";\n\noption java_package = \"cn.sunist.project-analysis.grpc\";\noption java_multiple_file = false;\noption java_outer_classname = \"UpdateDataService\";\n\n// 更新区域数据rpc请求\nmessage UpdateDataRequest &#123;\n\tmessage MapData &#123;\n\t\tstring LocationID = 1;\n\t\tstring LocationType = 2;\n\t&#125;\n\tint32 RequestTime = 1;\n\trepeated MapData MapRequest = 2;\n&#125;\n\n// 更新区域数据rpc响应\nmessage UpdateDataResponse &#123;\n\tmessage MapData &#123;\n\t\tstring LocationID = 1;\n\t\tstring LocationType = 2;\n\t\tbool LocationUpdateStatus = 3;\n\t&#125;\n\trepeated MapData MapResponse = 1;\n&#125;\n\n// 更新区域数据rpc服务: 根据时间和地点列表，更新全部请求区域的数据，并将处理结果返回\nservice UpdateData &#123;\n\trpc updateData(UpdateDataRequest) returns (UpdateDataResponse);\n&#125;\n\n3.2 后端接口\nOAuth模块\nNewClient: 新建OAuth客户端(http)\nNewUser: 新建OAuth用户(http)\nToken: 申请OAuth的Token(http)\nRefreshToken: 申请OAuth的RefreshToken(http)\nIntrospect: 验证OAuth的Token(http)\n\n\nOverview模块\nMapOverview: 获取某区域的疫情概况(http)\n\n\nStatistics模块\nMapStatistic: 获取某区域的疫情统计(http)\n\n\nCron模块\nProcess: 执行Cron任务(http)\nReport: 查看Cron任务的执行状况(http)\nOptions: 更改Cron任务配置(http)\n\n\nTrace模块缺省，有空再做\n\n","slug":"ProjectAnalysisDesignDocument","date":"2022-06-26T16:00:00.000Z","categories_index":"blog","tags_index":"Backend,Golang,Big Data,Java","author_index":"𝚂𝚞𝚗𝚒𝚜𝚝𝙲"},{"id":"c241d614c6965b00ab46082015324893","title":"学习笔记 - 计算机网络","content":"协议1. TCP网络的分层TCP网络分层分为应用层、传输层、网络互联层、网络访问层和物理层五层。以HTTP为例，从客户端到服务端之间的通信，需要经过以下步骤：\nClient的通信\n(应用层)根据HTTP协议组装数据包\n(传输层)将端口号、序列号等组装进TCP头部，增加到数据包内\n(网络互联层)将源IP地址等信息组装进IP头部，增加到数据包内\n(网络访问层)将MAC地址等信息组装进以太网头部，增加到数据包内\n(物理层)通过物理层发送数据包\n\nServer的通信\n(物理层)从物理层接受数据包\n(网络访问层)取出以太网中的以太网头部，根据MAC地址判断包是不是发给自己的\n(网络互联层)取出IP包进行IP报文解析，确定传送数据包与路由\n(传输层)取出TCP包进行TCP报文解析\n(应用层)取出HTTP包，并作出HTTP报文解析\n\n设计优势TCP网络分层的优势如下：\n\n各层独立 限制了依赖关系的范围，各层之间使用标准化的接口，各层不需要知道上下层实现原地，增加或者修改一个应用协议不会影响其他层级\n灵活性高 依赖某一层级的软件或者硬件，只需要处理好本层级的逻辑即可，不需要加载其他层级\n易于测试和维护 提高了可测试性，可以对某一层独立测试，也可以进行整体替换\n\n2. TCP的三次握手TCP的三次握手用于建立TCP连接\n流程TCP的Client和Server之间的三次握手流程如下：\n\nClient发送连接请求，SYN seq = x\nServer响应请求，SYN seq = y, ACK = x + 1\nClient确认Server的响应请求，ACK = y + 1\n\n必要性\n\n\n\n\n\n\n\n\nTCP协议是传输层协议，其本质是面向连接的协议\n\n若TCP是两次握手的话，则Server无法确认Client的连接能力，造成Server端的连接资源浪费\n因为确认双方通信能力只需要三次连接，若TCP是四次握手的话，则会造成双方的连接资源浪费\n\n3. TCP的四次挥手TCP的四次挥手用于断开TCP连接\n流程TCP的Client和Server之间的四次挥手流程如下：\n\nClient发送终止连接请求，FIN seq = x+2, ACK = y+1\nServer响应终止连接请求，ACK = x+3\nServer发送连接终止响应，FIN seq = y+1\nClient确认连接终止，ACK = y+2\n\n\n\n\n\n\n\n\n\n\n\n最近在投简历，才意识到要投实习了，先回去睡觉了，晚些再更\n","slug":"NetworkReview","date":"2022-04-14T13:38:28.000Z","categories_index":"blog","tags_index":"Algorithm,Backend,Network","author_index":"𝚂𝚞𝚗𝚒𝚜𝚝𝙲"},{"id":"aaa86bd7061c6b37fa4d0d3fb50508ac","title":"CeobeBot后端 - 设计","content":"\n\n\n\n\n\n\n\n\n先占个坑\n","slug":"CeobeBot-Backend","date":"2022-04-06T15:41:49.000Z","categories_index":"blog","tags_index":"Backend,Golang,CeobeBot","author_index":"𝚂𝚞𝚗𝚒𝚜𝚝𝙲"},{"id":"ad6656b837719f2ab38e772bf34bead7","title":"CeobeBot插件 - 明日方舟模块","content":"\n\n\n\n\n\n\n\n\n本blog供CeobeBot相关维护者开发插件时参考，本插件的实际仓库地址为：SchwarzPlatform::VCS(请使用实验室网络访问)，外部仓库地址为: GitHub，镜像地址为: Gitea。外部仓库与镜像仓库的更新可能不及时\n1. 设计思路1.1 ArknightsPlugin与CeobeBot的对接整个明日方舟模块与CeobeBot解藕，以独立项目的形式运行，在ArknightsPlugin模块中，将所有的依赖如DbConnection/gin.Engine/log.Logger等组件抽离，在依附于CeobeBot运行时，从外部获取相应组件，在独立运行时，使用main包独立创建相关组件实体\nArknightsPlugin在设计时被赋予以下功能：\n\n基础信息查询，如干员信息、材料信息等\n公开招募模拟，如根据tag来获取公开招募结果，或根据游戏截图，使用ocr来获取tag，然后获取公开招募结果\n模拟抽卡，使用明日方舟已公开的抽卡模型，即固定概率+补正概率，向使用者返回抽卡结果\n数据同步，即让本插件的干员信息、卡池信息等定期与公开游戏数据同步\n\n则现在，用户在CeobeBot中使用ArknightsPlugin提供的功能，过程为：\n\nAdachiBot前端获取用户指令，并向CeobeBot后端发起调用\nCeobeBot后端进行鉴权等流程，然后调用ArknightsPlugin的接口\nCeobeBot后端处理并返回响应给AdachiBot\nAdachiBot将响应解析并渲染、发送给用户\n\n1.2 模块设计ArknightsPlugin的主要模块由core，module和middleware三个包构成\ncore包core包内是所有CRUD业务逻辑的实现，包括下述文件：\ncore.go  // core包的公共实现，诸如init，获取配置，实例化必须组件等实现\nrecruit.go  // 公开招募的实现，包括tag筛选，笛卡尔积计算，结果确定等实现\ninfo.go  // 基础信息等实现，包括获取干员基本信息，获取材料基本信息等实现\ngacha.go  // 模拟抽卡的实现，包括概率计算，抽卡期望(还需要多少抽出货)计算等实现\n\nmodule包module包是所有ArknightsPlugin所需数据库模型数据的结构，包括下述文件：\nglobal.go  // 插件内全局变量的定义，如dbConnection/configData/apiRouter等\nconfig.go  // 插件运行所需的必要配置，如databaseConfig/ocrConfig/routerConfig等\noperator.go  // 干员相关信息的定义，如干员技能，干员属性，干员信息等\nmaterial.go  // 材料信息的相关定义，如材料信息、合成表等\nrecruit.go  // 公招相关信息的定义，如tag信息等\ngacha.go  // 抽卡信息的相关定义，如卡池信息、抽卡记录等\n\nmiddleware包mdiileware包是所有ArknightsPlugin所需工具类辅助功能的实现，包括下述分包：\nsyncer  // 从GitHub公开的ArknightsGameData同步明日方舟数据到本地\nfileReader  // 从文件获取数据如配置信息，数据库等到ArknightsPlugin\nfileWriter  // 输出Arknights产生的数据如日志等到文件\n\napi包api包是将core包实现的逻辑使用gin框架包装为http服务的实现。\n1.3 API设计\n\n\n\n\n\n\n\n\n具体API文档请转到项目wiki\n:/recruitGET :/recruit/ocr\nbody: application/json，传输图片base64编码\n通过ocr进行公招模拟\nGET :/recruit/tags?tag=${tagArray}\nbody: null\n通过词条进行公招模拟\nGET :/recruit/operator/:operatorName\nbody: null\n通过干员名称获取其公招词条，干员名为空则返回所有能够公招的干员及其词条\nGET :/recruit/tag/:tagName\nbody: null\n通过词条获取该词条能够招募到的干员，词条名为空则返回所有词条及其可招募干员\n:/infoGET :/info/operator/:operatorName\nbody: null\n通过干员名称获取干员信息，干员名称为空则返回干员列表\nGET :/info/material/:materialName\nbody: null\n通过材料名称获取材料信息，材料名称为空则返回材料列表\n:/gachaGET :/gacha/:tableName?count=${count}\nbody: application/json，抽卡者的信息\n对tableName池进行count次抽卡，count为空则默认十连，tableName为空则返回卡池列表，tableName为up则对最新up池进行抽卡\nGET :/gacha/:uid/statisitc?from=${date}\nbody: application/json，抽卡者的信息\n根据uid获取用户从date至今的抽卡记录，from为空则返回最近一百条抽卡记录，uid为空则返回401\n:/manageGET: :/manage/:commandName\nbody: application/json，管理者信息\n对ArknightsPlugin进行管理，执行commandName对应的操作，commandName为空则返回命令列表，用户鉴权不通过则返回403\n1.4 组件选用API框架API框架选用老牌的go-gin，性能强劲上手简单\n数据库由于ArknightsPlugin的数据量很小，只有百来个干员和百来种材料，全放内存也就几MiB，并且也是只读数据。所以选用json文件作为数据存储格式，在插件启动时将所有的数据读入内存，若后期数据量扩大，可换用sqlite，模拟抽卡记录也没什么业务价值丢了就丢了，所以选用go-cache在内存里造，不污染内存就可以了，若用户量大了，需要持久化，则分块写csv或json来保存\n分布式这么小个插件(笑)上什么分布式\n1.5 升级规划\n当CeobeBot功能逐步扩张，采用分布式架构时，将本插件以微服务方式添加到CeobeBot\n当用户规模或数据规模大量增加时，采用数据库或redis等组件以维护程序运行时数据\n使用rpc替代http以提高调用效率\n使用GraphQL或neo4j等构建更大规模的明日方舟数据集，将干员关系、剧情等联系起来\n\n2. 准备工作2.1 获取Arknights的游戏数据\n\n\n\n\n\n\n\n\n本文所使用的方法目的均为探讨学习先进技术，不作它用\n去GitHub上寻找ArknightsGameData相关仓库，并分析其数据结构。将其反序列化并组合到ArknightsPlugin内置的模型中，由于米娜桑获取的GameData结构可能不一样，此处就不公开反序列化代码了\n也可以自己到prts.wiki或wiki.biligame.com自己爬取\n2.2 设计Arknights相关实体的数据模型Operator下面是ArknightsPlugin在最初设计时的Operator：\npackage module\n\n// Operator Arknights干员\ntype Operator struct {\n\tName            string                      `json:\"name\"`            // 干员姓名\n\tStar            int                         `json:\"star\"`            // 干员星级\n\tType            string                      `json:\"type\"`            // 干员类型(职业)\n\tRedeploy        int                         `json:\"redeploy\"`        // 干员再部署时间\n\tCost            int                         `json:\"cost\"`            // 干员部署费用\n\tBlock           int                         `json:\"block\"`           // 干员阻挡数\n\tAttackInterval  float64                     `json:\"attack_interval\"` // 干员攻击间隔\n\tTrustFix        string                      `json:\"trust_fix\"`       // 干员信任修正\n\tProperties      Property                    `json:\"properties\"`      // 干员基础属性\n\tFlightSkills    []FlightSkill               `json:\"flight_skills\"`   // 干员战斗技能\n\tLogisticsSkills []LogisticsSkill            `json:\"logisticsSkills\"` // 干员后勤技能\n\tTalents         []Talent                    `json:\"talents\"`         // 干员天赋\n\tPotentials      []Potential                 `json:\"potentials\"`      // 干员潜能\n\tMods            []Mod                       `json:\"mods\"`            // 干员模组\n\tMaterials       map[string][]MaterialDemand `json:\"materials\"`       // 干员材料需求\n\tTags            []string                    `json:\"tags\"`            // 干员公招Tag数组\n}\n\n// Property 干员基础属性\ntype Property struct {\n\tHealth       int                      `json:\"health\"`        // 生命值\n\tAttack       int                      `json:\"attack\"`        // 攻击力\n\tDefence      int                      `json:\"defence\"`       // 防御力\n\tMagicDefence int                      `json:\"magic_defence\"` // 魔法防御力\n\tcalculator   func(level int) Property // 属性计算器\n}\n\n// FlightSkill 干员战斗技能\ntype FlightSkill struct {\n\tName            string   `json:\"name\"`             // 技能名称\n\tIconAddress     string   `json:\"icon_address\"`     // 技能icon地址\n\tType            string   `json:\"type\"`             // 技能类型\n\tTriggerType     string   `json:\"trigger_type\"`     // 技能触发类型\n\tContinuanceType string   `json:\"continuance_type\"` // 技能耐久类型\n\tDescription     []string `json:\"description\"`      // 技能数值\n\tSPStart         []int    `json:\"sp_start\"`         // 技能初始极力\n\tSPCost          []int    `json:\"sp_cost\"`          // 技能SP消耗\n\tContinuance     []int    `json:\"continuance\"`      // 技能耐久\n}\n\n// LogisticsSkill 干员后勤技能\ntype LogisticsSkill struct {\n\tName        string `json:\"name\"`         // 技能名称\n\tIconAddress string `json:\"icon_address\"` // 技能icon地址\n\tUnlockRank  int    `json:\"unlock_rank\"`  // 解锁条件\n\tType        string `json:\"type\"`         // 技能类型\n\tDestination string `json:\"destination\"`  // 生效地点\n\tDescription string `json:\"description\"`  // 技能描述\n}\n\n// Talent 干员天赋\ntype Talent struct {\n\tIndex       int    `json:\"index\"`       // 天赋序号\n\tName        string `json:\"name\"`        // 天赋名称\n\tRank        int    `json:\"rank\"`        // 所需等阶\n\tPotential   int    `json:\"potential\"`   // 所需潜能\n\tDescription string `json:\"description\"` // 天赋描述\n}\n\n// Potential 干员潜能\ntype Potential struct {\n\tIndex       int    `json:\"index\"`       // 潜能数\n\tDescription string `json:\"description\"` // 潜能效果\n}\n\n// Mod 干员模组\ntype Mod struct {\n\tName        string `json:\"name\"`         // 模组类型\n\tPropertyFix string `json:\"property_fix\"` // 数值修正\n\tTalentFix   string `json:\"talent_fix\"`   // 天赋修正\n}\n\n// MaterialDemand 材料需求\ntype MaterialDemand struct {\n\tName  string `json:\"name\"`  // 需求材料\n\tCount int    `json:\"count\"` // 需求数量\n}\n\nMaterial下面是ArknightsPlugin在最初设计时的Module：\npackage module\n\n// Material Arknights培养材料\ntype Material struct {\n\tName               string   `json:\"name\"`                // 材料名称\n\tRank               int      `json:\"rank\"`                // 材料等级\n\tDescription        string   `json:\"description\"`         // 材料描述\n\tObtainMission      []string `json:\"obtain_mission\"`      // 材料获取关卡\n\tSyntheticMaterials []string `json:\"synthetic_materials\"` // 材料合成素材\n}\n\n2.3 设计Syncer的定期同步流程\n在GiteaMirror一份GameData仓库，把定期cron的操作交给Gitea执行\n在Mirror仓库配置webhook，每触发一次Push，则向CeobeBot发送信息\n使用CeoebBot调用ArknightsPlugin的Sync()方法\n\n3. 具体实现\n\n\n\n\n\n\n\n\n由于CRUD的过程比较无聊，米娜桑都没问题，就只讲重点了\n3.1 模拟公招的词条组合模拟公招时，以提供五个词条为例，需要将五个词条的所有一词条、二词条、三词条组合都列出，并逐一在公招规则中进行查询，现在需要计算需要查询的词条组合\n最简单的办法自然是暴力，获取词条组合这个问题可等价于对一个集合\n\n进行次笛卡尔积，将所有结果排序后去重，得到的结果即为所求结果\n\n\n\n\n\n\n\n\n\n但是，这个方法效率奇差，不算排序和去重，光是笛卡尔积就需要计算次，而此问题的目标输出规模为，显然过于离谱\n然后自然而然想到了对集合进行全排列，然后进行排序去重，不算排序和去重的话，递归进行全排列的运算次数为次，此时已经优化了很多了，但还是太离谱了\n最后就想到了少有提起的全组合，全组合天然的优势是不用去重和排序，并且全组合的运算次数为次，已经和目标的输出规模很接近了，故采用全组合来实现此需求\n对于全组合，我们只需要开辟一个bool数组虽然最后优化掉了，长度与集合的元素个数相同即可，按位对应，其true/false即为集合对应元素是否出现在结果中，遍历完数组的每一个状态，全组合也就求完了。其golang实现如下：\nfunc combination(tags []string) (result [][]string) {\n\tlength := len(tags)\n\tupperBound := 1&lt;&lt;length\n\tresult = make([][]string, upperBound-1)\n\n\tfor i := 1; i &lt; upperBound; i++ {\n\t\ttemp := \"\"\n\t\tfor j := 0; j &lt; length; j++ {\n\t\t\tif i&gt;&gt;j == 0 {\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\tif (i&gt;&gt;j)^1 == 1 {\n\t\t\t\t\ttemp += tags[j] + \",\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult[i-1] = strings.Split(strings.TrimRight(temp, \",\"), \",\")\n\t}\n\n\treturn result\n}\n\n3.2 模拟抽卡的随机数生成由于完全随机较容易出现极端值，我们可以调一个正态的图形出来\n\n\n\n\n\n\n\n特别注意\n尝试过调模型了，事实证明这个活适合专业人士去干，想用大家喜闻乐见的十倍开根号进行修正，结果调出了极其奇怪的图像🤦‍♀️，有兴趣的勇士可以自己去试试\n\n简单测试了一下rand库的随机数函数的生成效率，生成组，每组个随机数，所用时间为十二秒(测试平台为Apple M1)，对于抽卡而言性能我猜够了\ngacha的实现如下，精确度为小数点后六位虽然用int摁写好像有点怪怪的，需在外部提前执行rand.Seed()：\nfunc gacha(alreadyGacha, count, fourStar, fiveStar, sixStar, sixStarCorrection int) (result []int) {\n\tresult = make([]int, count)\n\tcorrectionSixStar := sixStar\n\t\n\tfor i, _ := range result {\n\t\tif alreadyGacha &gt;= 50 {\n\t\t\tcorrectionSixStar += sixStarCorrection\n\t\t}\n\n\t\tprop := rand.Int() % 1000000\n\t\talreadyGacha += 1\n\t\tif prop &lt; fourStar {\n\t\t\tresult[i] = 3\n\t\t\tcontinue\n\t\t}\n\t\tswitch {\n\t\tcase prop &gt; correctionSixStar:\n\t\t\tresult[i] = 6\n\t\t\talreadyGacha = 0\n\t\t\tcorrectionSixStar = sixStar\n\t\tcase prop &gt; fiveStar:\n\t\t\tresult[i] = 5\n\t\tdefault:\n\t\t\tresult[i] = 4\n\t\t}\n\t}\n\n\treturn result\n}\n\n上面的实现没有四星保底，虽然官方也没有明确说十连一定出紫，有时间下次一定再改\n3.3 模拟抽卡的期望计算我们知道随机事件发生的概率为，即抽卡出货的概率为%，那么的对立事件即抽卡不出货的概率为%%，则连续两次抽卡不出货的概率为%，以此类推，五十抽以内，前次抽卡都不出货的概率\n但是当抽卡次数达到抽以上时，将会触发概率补正，即增加%的额外概率，五十抽以后，再抽一发还不出货的概率为，其中为该抽前不出货的概率，%，为已经抽卡次数\n那么连续抽次都不出货的概率表达式如下：\n\n那么，连续抽次至少出一张六星的概率，我们假定当至少出一张六星的概率大于%时，下一抽必出货\n顶着float64溢出的边缘计算，得到结果：当抽卡次仍没出货时，下一抽的出货的概率至少为%，好想去问候鹰角为什么我四五次到了70~77抽才出货\n至于那个网上流传已久的期望抽是怎么来的，可以参考这里知乎 - 从明日方舟抽卡机制开始的些微探索，我只能说我等非酋永远是被平均的\n上面这个实现太简单了就略\n\n\n\n\n\n\n\n\n\n\n先这么多，其他的想到再写\n","slug":"CeobeBot-ArknightsPlugin","date":"2022-04-01T08:52:36.000Z","categories_index":"blog","tags_index":"Backend,Golang,CeobeBot,Arknights","author_index":"𝚂𝚞𝚗𝚒𝚜𝚝𝙲"},{"id":"f8e8d6bc4eb4a88923ac2738fbdf0bbf","title":"浅记sync.WaitGroup使用时的一些错误","content":"\n\n\n\n\n\n\n\n\n此处所使用的代码均为演示出现的错误\n1. sync.WaitGroup传递方式不当导致negative counter错误代码package main\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\tch := make(chan struct{}, 10)\n\twg := sync.WaitGroup{}\n\tgo Println(ch, wg)\n\tgo Insert(100, ch, wg)\n\twg.Wait()\n}\n\nfunc Println(ch chan struct{}, wg sync.WaitGroup) {\n\tindex := 1\n\tfor {\n\t\tselect {\n\t\tcase &lt;-ch:\n\t\t\tprintln(index)\n\t\t\tindex++\n\t\t\twg.Done()\n\t\tdefault:\n\t\t\tprintln(\"wait for printing...\")\n\t\t\ttime.Sleep(time.Millisecond)\n\t\t}\n\t}\n}\n\nfunc Insert(times int, ch chan struct{}, wg sync.WaitGroup) {\n\tfor i := 0; i &lt; times; {\n\t\tselect {\n\t\tcase ch &lt;- struct{}{}:\n\t\t\ti++\n\t\t\twg.Add(1)\n\t\tdefault:\n\t\t\tprintln(\"wait for inserting...\")\n\t\t\ttime.Sleep(time.Millisecond)\n\t\t}\n\t}\n}\n\n报错信息panic: sync: negative WaitGroup counter\n\ngoroutine 3 [running]:\nsync.(*WaitGroup).Add(0x1400009a000, 0xffffffffffffffff)\n        /opt/homebrew/Cellar/go/1.17.8/libexec/src/sync/waitgroup.go:74 +0x14c\nsync.(*WaitGroup).Done(...)\n        /opt/homebrew/Cellar/go/1.17.8/libexec/src/sync/waitgroup.go:99\nmain.Println(0x140000160c0, {{}, {0x0, 0x1, 0x0}})\n        $ProjectPath/main.go:24 +0x94\ncreated by main.main\n        $ProjectPath/main.go:12 +0x98\n\nProcess finished with the exit code 2\n\n错误原因查询了一下资料后^1，发现此错误的原因是sync.WaitGroup在参数传递时应该使用指针传递地址，如果直接传值则会发生拷贝，此时传入的WaitGroup并不会被另一个go程修改\n此处也触发了一个啸啸的知识盲区，因为一前用slice和interface的时候特别顺手，其传递实际上传递的是共享的指针，仔细查阅了^1以后才发现，go参数传值是传递的拷贝，但是因为上面那些结构实际上有指向实际位置的指针，导致虽然传递的是拷贝，但是还是能对原参数进行修改，以后在编程时需要留心这一点避免造成内存泄漏。\n此处也挂一下引申的阅读资料： Go函数参数传递^2\n错误更正只需修改Println和Insert两个函数参数即可\n// ... code before\n\nfunc main() {\n    ch := make(chan struct{}, 10)\n    wg := &amp;sync.WaitGroup{}\n\tgo Println(ch, wg)\n\tgo Insert(100, ch, wg)\n\twg.Wait()\n}\n\nfunc Println(ch chan struct{}, wg *sync.WaitGroup) {\n    // ...implements\n}\n\nfunc Insert(times int, ch chan struct{}, wg sync.WaitGroup) {\n    // ...implements\n}\n\n2. sync.WaitGroup在go程内操作不当导致未能阻塞住主进程错误代码package main\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\nfunc main() {\n\tch := make(chan struct{}, 10)\n\twg := sync.WaitGroup{}\n\twg.Add(1)\n\tgo Println(ch, wg)\n\tgo Insert(100, ch, wg)\n\twg.Wait()\n}\n\nfunc Println(ch chan struct{}, wg sync.WaitGroup) {\n\tindex := 1\n\tfor {\n\t\tselect {\n\t\tcase &lt;-ch:\n\t\t\tprintln(index)\n\t\t\tindex++\n\t\t\twg.Done()\n\t\tdefault:\n\t\t\tprintln(\"wait for printing...\")\n\t\t\ttime.Sleep(time.Millisecond)\n\t\t}\n\t}\n}\n\nfunc Insert(times int, ch chan struct{}, wg sync.WaitGroup) {\n\tfor i := 0; i &lt; times; {\n\t\tselect {\n\t\tcase ch &lt;- struct{}{}:\n\t\t\ti++\n\t\t\twg.Add(1)\n\t\tdefault:\n\t\t\tprintln(\"wait for inserting...\")\n\t\t\ttime.Sleep(time.Millisecond)\n\t\t}\n\t}\n}\n\n报错信息无报错信息，但是程序会提前退出\n错误原因在Insert函数中，成功往chanel内写入了一个信号，便会触发一次WaitGroup.Add()，但是同时，在Println函数中，成功打印了一个数字，也会触发一次WaitGroup.Done()，有可能出现Insert写入次数与Println打印次数相等的时候，此时WaitGroup的计数器为0，main中的WaitGroup.Wait()便不会阻塞程序，导致程序意外结束运行，而两个go程没有达到预期的作业效果\n错误更正需要将生产者Insert的操作也当作一次作业完成，并且在WaitGroup被创建时，也需要将计数器+1直到生产者将总作业数设置完毕，以防生产者Insert函数和消费者Println函数都未正式执行时，main函数执行到了WaitGroup.Wait()，此时计数器依旧为0，程序依然会意外退出\n// ... code before\n\nfunc main() {\n    ch := make(chan struct{}, 10)\n    wg := &amp;sync.WaitGroup{}\n    wg.Add(1)\n\tgo Println(ch, wg)\n\tgo Insert(100, ch, wg)\n\twg.Wait()\n}\n\nfunc Insert(times int, ch chan struct{}, wg *sync.WaitGroup) {\n    wg.Add(2*times)\n    wg.Done()\n    for i := 0; i &lt; times; {\n\t\tselect {\n\t\tcase ch &lt;- struct{}{}:\n\t\t\ti++\n\t\t\twg.Done()\n\t\tdefault:\n\t\t\tprintln(\"wait for inserting...\")\n\t\t\ttime.Sleep(time.Millisecond)\n\t\t}\n\t}\n}\n\n// ... code after\n\n引用文章\n你真的会用sync.WaitGroup吗 - gnehsbc\nGo函数参数传递 - 富士康质检员张全蛋\n\n\n\n","slug":"WaitGroup-Blog","date":"2022-02-17T08:15:59.000Z","categories_index":"blog","tags_index":"Golang,Concurrency,sync.WaitGroup","author_index":"𝚂𝚞𝚗𝚒𝚜𝚝𝙲"},{"id":"b8d46bdb901a3fa647b17fec08a37916","title":"飞书小程序同步课表与日历","content":"\n\n\n\n\n\n\n\n\n飞书更新了API，程序目前无法运行，尚在FIX\n1. 准备工作1.1 创建飞书小程序略\n1.2 给机器人添加相应权限略\n1.3 分析课表结构西南大学教务系统返回的课表可以在开发者工具中看到具体数据，是json格式的一个文件。\n\n\n\n\n\n\n\n\n\n由于西南大学教务系统的鉴权流程过于阴间，我们至今未能知道它到底用的是cookie还是JWT还是OAuth，抑或是是中的一种，因为这些数据他都传输过，所以课表数据直接使用这个json文件，不管登陆流程。\n然后我们对照各种奇怪的命名方式，分析出了我们需要的结构：\n// Response 响应体的结构\ntype Response struct {\n\tStudentInfo struct {\n\t\tStudentClass  string `json:\"BJMC\"` // 学生班级 | 班级名称\n\t\tStudentName   string `json:\"XM\"`   // 学生姓名 | 姓名\n\t\tStudentNumber string `json:\"XH\"`   // 学生学号 | 学号\n\t} `json:\"xsxx\"`                     // 学生信息\n\tLessonList []Lesson `json:\"kbList\"` // 课程列表\n}\n\n// 课程信息的结构\ntype Lesson struct {\n\tLessonName         string `json:\"kcmc\" example:\"计算机网络\"`  // 课程名称\n\tLessonType         string `json:\"kclb\" example:\"学科基础课程\"` // 课程类别\n\tLessonProperty     string `json:\"kcxz\" example:\"学必\"`     // 课程性质\n\tLessonScore        string `json:\"xf\" example:\"3.5\"`      // 课程学分 | 学分\n\tLessonTeacher      string `json:\"xm\" example:\"丁华峰\"`      // 授课教师 | 姓名\n\tLessonClassroom    string `json:\"cdmc\" example:\"荣昌9302\"` // 上课地点 | 场地名称\n\tLessonIsExperiment string `json:\"xslxbj\" example:\"◆\"`    // 是否是实验课 | 显示类型标记\n\tLessonStartEndTime string `json:\"jcor\" example:\"1-2\"`    // 课程起止时间\n\tLessonStartEndDate string `json:\"zcd\" example:\"1-12周\"`   // 课程起止日期\n\tLessonWeekday      string `json:\"xqj\" example:\"2\"`       // 课程日期 | 星期几\n\tLessonTeacherTitle string `json:\"zcmc\" example:\"讲师（高校）\"` // 授课教师职称 | 职称名称\n}\n\n我们只需要将json数据反序列化到这个结构体中，就可以执行下一步操作了。\n1.4 计算日程时间由于教务系统返回的时间为第几节课，所以需要我们手动将第几节课转换为具体时间，方便以RFC标准发送到飞书后端。\n\n\n\n\n\n\n\n\n\n此处由于西南大学教务处最近调整了每节课的上下课时间，此处代码无参考意义。而且此处不应该使用硬编码。\n// CalculateTimeMap 将时分信息转换为需要的整型\nfunc CalculateTimeMap(hour, minute int) int {\n\treturn (hour-8)*60+minute\n}\n\nfunc CalculateDateStartEnd(l Lesson) (starts, ends time.Time, ending int) {\n\tDateStartEnd := strings.Split(strings.Replace(l.LessonStartEndDate, \"周\", \"\", -1), \"-\")\n\tTimeStartEnd := strings.Split(l.LessonStartEndTime, \"-\")\n\tLessonTipsStart := []int{\n\t\tCalculateTimeMap(8, 0),\n\t\tCalculateTimeMap(8, 55),\n\t\tCalculateTimeMap(10, 0),\n\t\tCalculateTimeMap(10, 55),\n\t\tCalculateTimeMap(12, 10),\n\t\tCalculateTimeMap(13, 5),\n\t\tCalculateTimeMap(14, 0),\n\t\tCalculateTimeMap(14, 55),\n\t\tCalculateTimeMap(15, 50),\n\t\tCalculateTimeMap(16, 55),\n\t\tCalculateTimeMap(17, 50),\n\t\tCalculateTimeMap(19, 20),\n\t\tCalculateTimeMap(20, 15),\n\t\tCalculateTimeMap(21, 10),\n\t}\n\tLessonTipsEnd := []int{\n\t\tCalculateTimeMap(8, 45),\n\t\tCalculateTimeMap(9, 40),\n\t\tCalculateTimeMap(10, 45),\n\t\tCalculateTimeMap(11, 40),\n\t\tCalculateTimeMap(12, 55),\n\t\tCalculateTimeMap(13, 50),\n\t\tCalculateTimeMap(14, 45),\n\t\tCalculateTimeMap(15, 40),\n\t\tCalculateTimeMap(16, 35),\n\t\tCalculateTimeMap(17, 40),\n\t\tCalculateTimeMap(18, 35),\n\t\tCalculateTimeMap(20, 5),\n\t\tCalculateTimeMap(21, 0),\n\t\tCalculateTimeMap(21, 55),\n\t}\n\tWeekDay, _ := strconv.Atoi(l.LessonWeekday)\n\tsD, _ := strconv.Atoi(DateStartEnd[0])\n\teD, _ := strconv.Atoi(DateStartEnd[1])\n\tsT, _ := strconv.Atoi(TimeStartEnd[0])\n\teT, _ := strconv.Atoi(TimeStartEnd[1])\n\tbasicTime := time.Date(2022, 2, 28, 8, 0, 0, 0, time.Local)\n\tstarts = basicTime.Add(time.Duration((sD-1)*24*7) * time.Hour).Add(time.Duration(LessonTipsStart[sT-1]) * time.Minute).Add(time.Duration((WeekDay-1) * 24) * time.Hour)\n\tends = basicTime.Add(time.Duration((sD-1)*24*7) * time.Hour).Add(time.Duration(LessonTipsEnd[eT-1]) * time.Minute).Add(time.Duration((WeekDay-1) * 24) * time.Hour)\n\tending = eD-sD+1\n\treturn\n}\n\n","slug":"LarkCalendarProgram","date":"2021-12-03T06:31:32.000Z","categories_index":"blog","tags_index":"lark,Backend,Golang","author_index":"𝚂𝚞𝚗𝚒𝚜𝚝𝙲"},{"id":"7c7ffd2e1448fe10d3fa1123a825b256","title":"服务端使用飞书机器人发送信息","content":"1. 准备工作1.1 创建飞书机器人文档： 开发流程与工具介绍\n1.2 给机器人添加相应权限文档： 应用权限\n1.3 获取 lark-sdk项目： chyroc&#x2F;lark\nlark是一个实现了飞书各API的golang模块，可以通过下面的方式获取lark\ngo get -u github.com&#x2F;chyroc&#x2F;lark\n\n2. 正式编程2.1 在服务端实例化larkcli := lark.New(\n    lark.WithAppCredential(\"appID\", \"appSecret\"),\n    lark.WithEventCallbackVerify(\"encryptKey\", \"verificationToken\"),\n)\n\n2.2 获取 token文档： 获取 tenant_access_token（企业自建应用）\nlark应用需要使用这个token作为标识来进行各种操作。\n\n\n\n\n\n\n\n\n\ntoken 有效期为 2 小时，在此期间调用该接口 token 不会改变。当 token 有效期小于 30 分的时候，再次请求获取 token 的时候，会生成一个新的 token，与此同时老的 token 依然有效。\nctx := context.Background()\nresponse, _, _ := cli.Auth.GetTenantAccessToken(ctx)\n\n若无意外，response 中的 Token 字段即为 tenant_access_token。\n2.3 获取 chat_id文档： 群ID 说明\nlark应用在发送信息的时候需要使用 chat_id 来识别应该发送到哪个会话。\n\n\n\n\n\n\n\n\n\nchat_id是一个群聊的唯一标识。当创建一个群聊的时候，系统会自动生成该ID。\nctx2 := context.WithValue(context.Background(), \"Authorization\", response.Token)\nresponse2, _, _ := cli.Chat.GetChatListOfSelf(ctx2, &amp;lark.GetChatListOfSelfReq&#123;&#125;)\n\n若无意外， response2 中的 Items 字段即为所有 chat_idß 的列表。\n2.4 发送信息文档： 发送消息\nlark应用可以调用飞书接口，实现信息发送。\nctx3 := context.Background()\ncli.Message.Send().ToChatID(\"chat_id\").SendText(ctx3, \"Hello\")\n\n若无意外，机器人就能将一条内容为 Hello 的信息发送到 chat_id 的聊天。\n3. 参考代码import (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/chyroc/lark\"\n)\n\nfunc main() &#123;\n\tcli := lark.New(\n        lark.WithAppCredential(\"appID\", \"appSecret\"),\n        lark.WithEventCallbackVerify(\"encryptKey\", \"verificationToken\"),\n\t)\n\tctx := context.Background()\n\n\tresponse, _, _ := cli.Auth.GetTenantAccessToken(ctx)\n\tfmt.Println(response.Token)\n\n\tctx2 := context.WithValue(context.Background(), \"Authorization\", response.Token)\n\tresponse2, _, _ := cli.Chat.GetChatListOfSelf(ctx2, &amp;lark.GetChatListOfSelfReq&#123;&#125;)\n\n\tctx3 := context.Background()\n\tfor _, x := range response2.Items &#123;\n\t\t_, _, _ = cli.Message.Send().ToChatID(x.ChatID).SendText(ctx3, `Hello`)\n\t&#125;\n&#125;\n\n4. 附记lark所提供的接口其实不太好用，更建议在开发的时候手动使用飞书官方的API接口进行调用。\n","slug":"LarkChatBackend","date":"2021-11-28T08:16:18.000Z","categories_index":"blog","tags_index":"lark,Backend,Golang","author_index":"𝚂𝚞𝚗𝚒𝚜𝚝𝙲"},{"id":"6744708d0acb1352be9f52cb85bacb83","title":"Hexo博客部署总结","content":"1. 环境配置1.1 nvm的安装a. 下载nvm安装包\n\n\n\n\n\n\n\n\nnvm的全称为node version manager，即node版本管理器，用于便捷的管理各个版本的node.js。\nnvm-windows的官方发布地址为： \nhttps://github.com/coreybutler/nvm-windows/releases。\n但是由于超级防火墙的原因，这个地址有的时候无法正常访问，需要大家使用科学的方式进行上网。\nb. 安装nvm将其下载到本机以后，解压后双击安装包并根据安装提示进行安装。\nc. 检验nvm是否安装成功在命令提示符窗口中，输入指令：\nnvm version\n\n来查看nvm的版本，如果安装成功，则应该会打印出nvm的版本：\n1.1.8\n\n1.2 Node的安装\n\n\n\n\n\n\n\n\nNode是语言JavaScript的运行环境。\na. 安装指定版本的Node.js在命令提示符窗口中，输入指令：\nnvm install ${version}\n\nversion为版本号，此处推荐版本为14，则可以输入：\nnvm install 14\n\nb. 使用指定版本的Node.js在命令提示符窗口中，输入指令：\nnvm use ${version}\n\nversion为版本号，此处推荐版本为14，则可以输入：\nnvm use 14\n\nc. 测试Node.js是否安装成功在命令提示符窗口中，输入指令：\nnode -v\n\n来查看node的版本，如果安装成功，则应该返回node的版本：\nv14.15.1\n\nd. 尝试运行JavaScript语句\n\n\n\n\n\n\n\n\n当然这个不是重点。\n由于JavaScript是解释型语言，其不需要进行编译，可以直接运行一些语句，此处我们来做一个简单的Hello, World程序。\n在命令提示符窗口中，输入指令进入node环境：\nnode\n\n然后输入JavaScript语句：\nconsole.log(\"Hello, World\")\n\n键入回车即可运行。运行结果为：\nHello, World\n\n1.3 Git的安装\n\n\n\n\n\n\n\n\nGit是一个版本管理工具\n下载地址： git-scm: download\n实验室加速地址： Git-Windows-64\n选择对应的系统直接下载即可。\n2. 初始化博客2.1 使用npm来安装hexo包\n\n\n\n\n\n\n\n\nnpm的全称为node package manager，意为Node包管理器，是node.js的一个官方工具，我们可以通过这个工具来获取我们想要的别人发布的node程序包。\nhexo是一个著名博客软件，可以快速的生成博客站点。\n为了加速npm的下载，我们一般会更换npm的下载源：\nnpm config set registry https://registry.npm.taobao.org \n\n在命令提示符窗口中，输入指令：\nnpm install hexo-cli -g\n\n来安装hexo和它的脚手架。如果没有报错的话，就是安装成功。\n2.2 使用hexo-cli创建一个博客项目在你想存储项目的目录下，输入指令：\nhexo init ${blog_name}\n\n其中blog_name是创建的博客站点的名字，也是文件夹的名字。如果没有报错的话，就是创建成功。\n2.3 使用hexo-cli创建博客网站在${blog_name}目录下，输入指令：\nhexo s\n\n然后就可以在它给你的地址访问你的博客网站了。\n3. 撰写博客内容在${blog_name}目录下，输入指令：\nhexo new post ${post_name}\n\n其中post_name是文章的标题，也是文章的uri。执行完成后，hexo会在./source/post目录下创建一个名为${blog_name}.md的文件，这是一个markdown文件。\n\n\n\n\n\n\n\n\n\nMarkdown是一种标记式写作语言，广泛在计算机领域、学术领域使用。\n编辑这个文件，保存后就可以到博客站点上查看变更后的内容了。\n4. Markdown语法Markdown主要有以下几种语法：\n\n标题\n列表\n有序列表\n无序列表\n待办列表\n\n\n媒体\n图片\n链接\n流程图\n\n\n表格\n公式\n引用\n代码\n行内代码\n代码块\n\n\n\n4.1 Markdown的标题#用于标记一级标题，如：\n# 我是一级标题\n\n##用于标记二级标题，如：\n## 我是二级标题\n\n###用于标记三级标题，如：\n### 我是三级标题\n\n4.2 Markdown的列表a. 无序列表+/-都可以用来标记无序列表，如：\n+ 我是列表项\n+ 我是列表项\n+ 我是列表项\n\n- 我是列表项\n- 我是列表项\n- 我是列表项\n\nb. 有序列表${index}.可以用来标记有序列表，如：\n1. 我是列表项1\n2. 我是列表项2\n3. 我是列表项3\n\nc. 待办列表- [ ]/- [x]可以用来标记待办列表，如：\n- [ ] 我没做完\n- [x] 我做完了\n\n显示效果如下：\n\n \n我没做完\n\n \n我做完了\n\n\n4.3 Markdown的媒体a. 图片![${pic_title}](${pic_uri})可以用来标记图片，如：\n![](https://swu-acm-lab.github.io/Ceobebot-Document/_media/CeobeBot.png)\n\n显示效果如下：\n\nb. 链接[${link_show_text}](${link_uri})可以用来标记链接，如：\n[CeobeBot - 刻俄柏机器人](https://swu-acm-lab.github.io/Ceobebot-Document/_media/CeobeBot.png)\n\n显示效果为：\nCeobeBot - 刻俄柏机器人\nc. 流程图\n\n\n\n\n\n\n\n\n流程图需要插件才能解析，此处不过多说明，建议在Typora中尝试\nflow是一个在markdown中画流程图的语言，如：\n```flow\nst=&gt;start: 开始\nop=&gt;operation: 操作\ned=&gt;end: 结束\n\nst-&gt;op-&gt;ed\n```\n\n显示效果为：\nst=&gt;start: 开始\nop=&gt;operation: 操作\ned=&gt;end: 结束\n\nst-&gt;op-&gt;ed\n\n4.4 Markdown的表格\n\n\n\n\n\n\n\n\n建议使用工具生成表格\nmarkdown的表格标记格式如下：\n| 列名1 | 列名2 |\n| :--: | :--: |\n| 内容1 | 内容2 |\n\n显示效果为：\n\n\n\n列名1\n列名2\n\n\n\n内容1\n内容2\n\n\n4.5 Markdown的公式\n\n\n\n\n\n\n\n\nMarkdown的公式使用LaTeX的公式语法。\na. 行内公式$用于标注行内公式，如：\n二次函数定义为： $y = f(x) = ax^2 + bx + c$\n\n显示效果如下：\n二次函数定义为： \nb. 块公式$$用于标注块公式，如：\n二次函数定义为$(1)$式：\n\n$$\ny = f(x) = ax^2 + bx + c \\tag{1}\n$$\n\n显示效果如下：\n二次函数定义为式：\n\n4.6 Markdown的引用&gt;用于标记引言，如：\n&gt; 我是名人名言\n\n显示效果如下：\n\n\n\n\n\n\n\n\n\n我是名人名言\n4.7 Markdown的代码a. 行内代码markdown行内代码的标注格式如下：\n`printf(\"hello\\n\")` 是一句代码\n\n显示效果如下：\nprintf(\"hello\\n\") 是一句代码\nb. 块代码markdown块代码的标注格式如下：\n```${language}\n${code_content}\n```\n\n其中language是代码的语言类型，一般为代码文件拓展名，code_content是代码块的内容，如：\n```cpp\n#include &lt;cstdio&gt;\n\nint main() {\n    printf(\"hello\\n\");\n    return 0;\n}\n```\n\n显示效果如下：\n#include &lt;cstdio&gt;\n\nint main() {\n    printf(\"hello\\n\");\n    return 0;\n}\n\n5. 将博客部署到网络上\n\n\n\n\n\n\n\n\n我们使用GitHub Pages服务来帮助我们部署。\n修改_config.yml文件，这个是博客项目的配置文件。找到deploy选项：\ndeploy:\n  type: git\n  repo: ${your_github_repo}\n  branch: ${your_repo_branch}\n  token: ${your_github_token}\n  name: ${your_name}\n  email: ${your_email_address}\n\n\n其中your_github_repo是你在GitHub创建的项目地址，your_repo_branch是你想部署的分支名，${your_github_token}是你在GitHub生成的访问密钥，${your_name}是你的大名(建议英文)，${your_email_address}是你的邮箱，建议和GitHub注册邮箱一致。\n安装hexo-deployer-git:\nnpm install hexo-deployer-git --save\n\n完成后，使用下面的指令：\nhexo d\n\n根据提示输入你的账号和密码，就可以部署到GitHub Pages上了。\n","slug":"HexoInit","date":"2021-11-06T01:59:06.000Z","categories_index":"blog","tags_index":"Hexo,Blog,GitHub Actions,GitHub Pages","author_index":"𝚂𝚞𝚗𝚒𝚜𝚝𝙲"},{"id":"33d946be9412bd8a90fb75fab5562d37","title":"2021级新生训练赛第一场题解","content":"轮到SunistC来给大一新生们写训练赛题解了。\niridescent迷上了神奇的数(5分) - 题解本题计算内有多少个素数，答案为。可以考虑三种思路，其中思路1无法及时得出结果。\n1. 暴力求解按照素数定义进行判断：\n#include &lt;iostream&gt;\n\nint main() {\n    int a = 11451419;\n    int ans = 1;\n    for (int i = 2; i &lt;= a; i++) {\n        for (int j = 2; j &lt;= i; j++) {\n            if (i % j == 0) {\n                ans += 1;\n                break;\n            }\n        }\n    }\n    std::cout &lt;&lt; a - ans &lt;&lt; std::endl;\n    return 0;\n}\n\n若不进行优化，本思路所用时间为 NaN。跑了半小时没跑出来。\n\n\n\n\n\n\n\n\n\n多线程暴力：\n在本思路的基础上，将区间拆分为若干等分，对每一个子区间新建线程进行暴力求解。这是打表法/暴力法的通用优化思路。\n在使用十六线程的情况下，本思路所用时间为： NaN。跑了半小时没跑出来。\n2. sqrt优化暴力在上面的算法中，其实并不需要按照定义一直判断到，我们只需要判断从到之间的整数就可以了。\n\n\n\n\n\n\n\n\n\n证明：\n若不是素数，则其可以表示为，我们不妨令。\n此时我们知道可能取得最大值时，有，即，此时。\n所以，即若不是素数，其必有一个因数在区间。\n证明完毕。\n优化后的具体代码为：\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nint main() {\n    int a = 11451419;\n    int ans = 1;\n    for (int i = 2; i &lt;= a; i++) {\n        int temp = sqrt(i); // 避免每次j的循环都进行一次开方运算\n        for (int j = 2; j &lt;= temp; j++) {\n            if (i % j == 0) {\n                ans += 1;\n                break;\n            }\n        }\n    }\n    std::cout &lt;&lt; a - ans &lt;&lt; std::endl;\n    \n    return 0;\n}\n\n使用本优化思路，所用时间为 4469ms 。\n3. 筛法考虑这样一件事情：如果是合数，那么的倍数也一定是合数。利用这个结论，我们可以避免很多次不必要的检测。如果我们从小到大考虑每个数，然后同时把当前这个数的所有（比自己大的）倍数记为合数，那么运行结束的时候没有被标记的数就是素数了。\n这个思路被称为筛法，也是筛法中最简单、时间复杂度最高的埃拉托斯特尼筛法，其时间复杂度为。\n具体代码为：\n#include &lt;iostream&gt;\n\n// 标准埃氏筛\nint Eratosthenes(int n, bool *is_prime, int *prime)\n{\n    int p = 0;\n    for (int i = 0; i &lt;= n; ++i)\n        is_prime[i] = 1;\n    is_prime[0] = is_prime[1] = 0;\n    for (int i = 2; i &lt;= n; ++i)\n    {\n        if (is_prime[i])\n        {\n            prime[p++] = i; // prime[p]是i,后置自增运算代表当前素数数量\n            if ((long long)i * i &lt;= n)\n                for (int j = i * i; j &lt;= n; j += i)\n                    // 因为从 2 到 i-1 的倍数我们之前筛过了，这里直接从 i\n                    // 的倍数开始，提高了运行速度\n                    is_prime[j] = 0; // 是i的倍数的均不是素数\n        }\n    }\n    return p;\n}\n\nint main()\n{\n    int a = 11451419;\n    bool *is_prime = new bool[a];\n    int *prime = new int[a];\n    int ans = Eratosthenes(a, is_prime, prime);\n    std::cout &lt;&lt; ans &lt;&lt; std::endl;\n    return 0;\n}\n\n使用本优化思路，所用时间为 93ms 。\n最大公约数(5分) - 题解本题计算与的最大公约数，答案为。可以考虑三种思路，其中思路1无法及时得出结果。\n手算如题，使用短除法等数学思路用手来算。\n暴力求解观察可知题中两数可能的最大公约数取值范围为，我们只需要对这个区间中的每一个数从大到小进行判断，看能否同时整除两数，满足条件的第一个数即为两数的最大公约数。\n#include &lt;iostream&gt;\n\nint main()\n{\n    long long a = 1145141919810, b = 60606;\n    for (int i = b; i &gt; 1; i--)\n    {\n        if (a % i == 0 &amp;&amp; b % i == 0)\n        {\n            std::cout &lt;&lt; i &lt;&lt; std::endl;\n            break;\n        }\n    }\n    return 0;\n}\n\n使用本思路，所用时间为 2ms 。\n欧几里得算法/辗转相除法在高中数学必修3第一章第三节中，有学过一个名为辗转相除法的算法，用于计算两个数的最大公约数，其程序框图如下：\nstart=&gt;start: 开始\ninput=&gt;inputoutput: 输入a, b\nmod=&gt;operation: c = a MOD b, a = b, b = c\njudge=&gt;condition: c = 0?\noutput=&gt;inputoutput: 输出a\nend=&gt;end: 结束\n\nstart-&gt;input-&gt;mod(right)-&gt;judge\njudge(yes)-&gt;output-&gt;end\njudge(no)-&gt;mod\n\n#include &lt;iostream&gt;\n\nlong long gcd(long long a, long long b) {\n\treturn b ? gcd(b, a % b) : a;\n}\n\nint main() {\n    long long a = 1145141919810, b = 60606;\n    std::cout &lt;&lt; gcd(a, b) &lt;&lt; std::endl;\n    return 0;\n}\n\n其中C标准库也封装了本算法：\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nint main() {\n    long long a = 1145141919810, b = 60606;\n    std::cout &lt;&lt; std::__gcd(a, b) &lt;&lt; std::endl;\n    return 0;\n}\n\n 使用本思路，所用时间为 1ms 。\nExcel处理数据(10分) - 题解本题为计算区间中去掉若干个区间后，有多少个数字，答案为。可以考虑两种思路。\n直接暴力直接从区间起点开始，到区间终点结束，每一个数判断其是否在去掉的区间内，如果在，则不计数，如果不在，则计数。\n#include &lt;iostream&gt;\n\nint count7(int n)\n{\n    int temp = n;\n    int ans = 0;\n    while (temp != 0)\n    {\n        ans += temp % 10 == 7 ? 1 : 0;\n        temp /= 10;\n    }\n    return ans;\n}\n\nbool should_calculate(int n, int *start, int *end)\n{\n    for (int i = 0; i &lt; 20; i++)\n    {\n        if (n &gt;= start[i] &amp;&amp; n &lt;= end[i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int starts[] = {14, 1139, 4998, 26789, 3, 11401, 38768, 92322, 52322, 87653, 113, 973, 49923, 28211, 4836, 89900, 68923, 112988, 348, 8909};\n    int ends[] = {78, 4789, 8907, 29876, 8, 11490, 40000, 102234, 58223, 89764, 294, 1004, 51008, 33387, 6982, 101102, 79321, 114326, 892, 10086};\n    int ans = 0;\n    for (int i = 1; i &lt;= 114514; i++)\n    {\n        if (should_calculate(i, starts, ends))\n        {\n            ans += count7(i);\n        }\n    }\n    std::cout &lt;&lt; ans &lt;&lt; std::endl;\n    return 0;\n}\n\n使用本思路，所用时间为： 1ms 。\n预处理将区间预先统一处理，节约了每个数判断是否在区间内的时间。\n#include &lt;iostream&gt;\n\nint count7(int n)\n{\n    int temp = n;\n    int ans = 0;\n    while (temp != 0)\n    {\n        ans += temp % 10 == 7 ? 1 : 0;\n        temp /= 10;\n    }\n    return ans;\n}\n\nint main() {\n    int starts[] = {14, 1139, 4998, 26789, 3, 11401, 38768, 92322, 52322, 87653, 113, 973, 49923, 28211, 4836, 89900, 68923, 112988, 348, 8909};\n    int ends[] = {78, 4789, 8907, 29876, 8, 11490, 40000, 102234, 58223, 89764, 294, 1004, 51008, 33387, 6982, 101102, 79321, 114326, 892, 10086};\n    bool *temparr = new bool[114516];\n    for (int i = 1; i &lt;= 114514; i++)\n    {\n        temparr[i] = true;\n    }\n    for (int i = 0; i &lt; 20; i++)\n    {\n        for (int j = starts[i]; j &lt;= ends[i]; j++)\n        {\n            temparr[j] = false;\n        }\n    }\n\n    int ans = 0;\n    for (int i = 1; i &lt;= 114514; i++)\n    {\n        if (temparr[i])\n        {\n            ans += count7(i);\n        }\n    }\n    \n    std::cout &lt;&lt; ans &lt;&lt; std::endl;\n    return 0;\n}\n\n使用本思路，所用时间为： 1ms 。\n","slug":"20211001-TrainningAssignmentAnserwer","date":"2021-10-02T08:12:30.000Z","categories_index":"answer","tags_index":"Algorithm,ACM,Answer","author_index":"𝚂𝚞𝚗𝚒𝚜𝚝𝙲"},{"id":"d3efaf25e370a6934d01ee2c4302e610","title":"训练笔记 - 计算几何","content":"计算几何基础入门计算几何是由微分几何、代数几何、数值计算、逼近论、拓扑学以及数控技术等形成的一门新兴边缘学科，其主要研究对象和内容是对自由形曲线、曲面的数学描述、设计、分析及图形的显示、处理等。\n对于浮点数的处理不要直接用等号判断浮点数是否相等！\n\n\n\n\n\n\n\n\n\n同样的一个数1.5。如果从不同的途径计算得来，它们的储存方式可能会是a=1.4999999 与 b=1.5000001，此时使用a==b判断将返回false。\n所以我们引入一个什么小的量 eps,在对浮点数进行大小比较时，如果他们的差的绝对值小于这个量，那么我们就认为他们是相等的。eps在大部分题目时取 1e-8或者1e-9 就够了，但要根据题目实际的内容进行调整。\n代码模板const double eps = 1e-8;\nbool dcmp(double x, double y){\n    if(fabs(x - y) &lt; eps){// 这里注意要使用fabs()，不能用abs().\n        return 0;//两数相等\n    }else if(x &gt; y){\n        return 1; //  x &gt; y\n    }\n    return -1;\n}\n\n浮点树输入输出用 scanf 输入浮点数时， double 的占位符是 %lf ，但是浮点数 double 在 printf 系列函数中的标准占位符是 %f 而不是 %lf ，使用时最好使用前者。\n开方我们一般使用的是double sqrt (double x)函数来进行对正数的开方，但是当输入负数时,sqrt 会返回 nan ，输出时会显示成 nan 或 -1.#IND00 （根据系统的不同）。如果对一个几乎接近0的负数，由上面的误差分析可以知道，这个负数与0相等，但是开方不能得到正确的答案。那么这时我们就需要自定义一个函数了。\ndouble mySqrt(double x) {\n    return max(0.0,sqrt(x));\n}\n\n负零输出时一定要小心不要输出 −0，比如\ndouble a = -0.000001;\nprintf(\"%.4f\", a);\n// -0.0000\n\n取整int fx = floor(x);//向下取整函数\nint cx = ceil(x);//向上取整函数\nint rx = round(x);//四舍五入函数\n\n\n向量简单来说，既有大小又有方向的量叫做向量在计算机中我们常用坐标表示\n点的定义我们使用结构体来存储点\nstruct Pt {\n    double x, y;//必要时使用int\n    Pt(double x, double y): x(x), y(y) { }\n};\n\n向量计算在高中和大学中，我们已经学过了向量的加减法，就不给出公式了。\n加法\n\n\n\n\n\n\n\n\n\npt operator + (pt A, pt B){\n    return pt(A.x+B.x, A.y+B.y);\n} \n\n减法\n\n\n\n\n\n\n\n\n\npt operator - (pt A, pt B){\n    return pt(A.x-B.x, A.y-B.y);\n} \n\n数乘向量的数乘是一个向量和实数的运算。\npt operator * (double A, pt p) { \n    return pt(p.x*A, p.y*A);\n}\npt operator * (pt p, double A) { \n    return pt(p.x*A, p.y*A);\n}\n\n点乘double dot(pt A, pt B){\n    return A.x*B.x + A.y*B.y; \n}\n应用点积可以用来计算两向量的夹角。\n叉积\ndouble det(pt A, pt B) { return A.x * B.y - A.y * B.x; }\n应用\n计算两个两个构成的平行四边形面积或者三角形面积\n根据的出现的正负来判断A与B向量的方向除法pt operator / (pt A, double p){\n    return pt(A.x/p, A.y/p);\n}\n等于运算bool operator == (const Point&amp; A, const Point&amp; B){\n    if(dcmp(A.x-B.x) == 0 &amp;&amp; dcmp(A.y-B.y) == 0)\n        return true;\n    return false;\n}\n长度double Length(pt A){\n    return mySqrt(Dot(A, A));\n}\n\ndouble Length(pt A){\n    return mySqrt(Dot(A, A));\n}\n\n","slug":"ComputationalGeometry","date":"2021-04-13T04:23:08.000Z","categories_index":"notes","tags_index":"Algorithm,ACM,Computational Geometry","author_index":"𝚂𝚞𝚗𝚒𝚜𝚝𝙲"},{"id":"a6bba6665e00ecf0e71f128b79f675d3","title":"训练笔记 - 概率论与数理统计","content":"第一章 概率论基本概念4. 事件独立性若事件和事件相互独立，则事件和事件，事件和事件，事件和事件也相互独立，若三个事件相互独立，则\n5. 全概率及贝叶斯公式5.1 全概率公式全概率公式为：\n$$P(A) = \\sum^{n}{i=1} {P(AB{i})} = \\sum^{n}{i=1} {P(A|B{i})P(B_{i})}$$\n即，当所求事件A可以分成可数种情况时，事件A发生的概率就是这些情况对应概率之和\n5.2 贝叶斯公式贝叶斯公式为：\n$$P(B_{i} | A) = \\frac{P(B_{i}A)}{P(A)} = \\frac{P(A|B_{i})P(B_{i})}{ \\sum^{n}{j=1}{P(A|B{j})P(B_{j})}}$$\n即，若已知结果A发生了，要判断是那种情况是，应当使用贝叶斯公式\ne.g. 设工厂甲和工厂乙的次品率分别是和，现在从甲工厂和乙工厂的产品分别占和的一批产品中随机抽取一件，求: (1)这件产品是次品的概率 (2)该次品是由假工厂生产的概率\nans. \n解：\n设事件为抽取的是次品，事件为该次品来自甲厂，表示该产品来自乙厂，则\n\n(1) 由全概率公式可知\n\n(2) 由贝叶斯公式可知\n\n第一章 概率论基本概念1. 随机事件与样本空间2. 事件概率3. 运算法则4. 事件独立性$$\\begin{aligned}\n  事件A和事件B独立 &amp;\\Longleftrightarrow P(AB) = P(A)P(B) \\\n  &amp;\\Longleftrightarrow P(B) = P(B|A) (P(A) &gt; 0)\\\n  &amp;\\Longleftrightarrow P(B|A) = P(B|\\overline{A}) (0 &lt; P(A) &lt; 1)\n\\end{aligned}$$\n若事件和事件相互独立，则事件和事件，事件和事件，事件和事件也相互独立，若三个事件相互独立，则\n5. 全概率及贝叶斯公式5.1 全概率公式全概率公式为：\n$$P(A) = \\sum^{n}{i=1} {P(AB{i})} = \\sum^{n}{i=1} {P(A|B{i})P(B_{i})}$$\n即，当所求事件A可以分成可数种情况时，事件A发生的概率就是这些情况对应概率之和\n5.2 贝叶斯公式贝叶斯公式为：\n$$P(B_{i} | A) = \\frac{P(B_{i}A)}{P(A)} = \\frac{P(A|B_{i})P(B_{i})}{ \\sum^{n}{j=1}{P(A|B{j})P(B_{j})}}$$\n即，若已知结果A发生了，要判断是那种情况是，应当使用贝叶斯公式\ne.g. 设工厂甲和工厂乙的次品率分别是和，现在从甲工厂和乙工厂的产品分别占和的一批产品中随机抽取一件，求: (1)这件产品是次品的概率 (2)该次品是由假工厂生产的概率\nans. \n解：\n设事件为抽取的是次品，事件为该次品来自甲厂，表示该产品来自乙厂，则(1) 由全概率公式可知(2) 由贝叶斯公式可知\n第二章 随机变量及其分布1. 基本概念1.1 分布函数\n分布函数\n\n分布函数的四个特征\n\n\n单调不减\n右连续\n\n\n\n分布函数的四个性质\n\n\n\n\n\n\n\n\n1.2 分布律\n分布律，仅适用于离散型变量\n\n\n\n\n\n1.3 概率密度函数\n概率密度函数，仅适用于连续型变量\n\n\n\n\n\n\n2. 常见随机变量分布2.1 离散型随机变量\n0-1分布\n二项分布\n分布律表达式： \n\n\n泊松分布\n分布律表达式： \n\n\n超几何分布\n分布律表达式： \n\n\n\n2.2 连续型随机变量\n均匀分布\n概率密度函数表达式： 其他\n\n\n指数分布\n概率密度函数表达式： \n\n\n正态分布\n概率密度函数表达式： \n，服从标准正态分布，其概率密度函数表达式为：，其分布函数为：\n正态分布具有以下性质：\n\n正态分布密度函数关于对称，即\n若，则，==这个性质非常重要==\n若，则\n\n\n\n\n\n3. 随机变量的变换3.1 离散型随机变量e.g. 设服从下述分布律，求解的分布律\n\n\n\n\n0\n1\n2\n3\n\n\n\n\n0.5\n0.2\n0.15\n0.15\n\n\nans.\n将的取值分别带入和，可以计算出它们的分布律为：\n\n\n\n\n1\n3\n5\n7\n\n\n\n\n0\n1\n4\n9\n\n\n\n0.5\n0.2\n0.15\n0.15\n\n\n3.2 连续型随机变量==TODO…==\n\n\n\n\n\n\n\n\n\nhttps://zhuanlan.zhihu.com/p/268870366\nCtrl+F: 连续型随机变量的题目相对麻烦一点，有的看过书的同学应该知道书上给出了几个公式用于计算连续型随机变量变换的题目，但是个人不建议去死记硬背那些公式，数学已然有很多公式要背了，能少一个是一个，接下来重点来了：\n第三章 多维随机变量及其分布前置：二重积分\n==TODO…==\n\n\n\n\n\n\n\n\n\n复习高等数学，如何进行二重积分\n1. 基本概念1.1 分布函数\n联合分布函数\n\n设为二维随机变量，则称为随机变量的联合分布函数\n联合分布函数具有以下基本特征与性质\n\n关于单调不减\n关于或者都是右连续\n\n\n\n\n\n边缘分布函数\n\n边缘分布函数即一维随机变量的分布函数，在计算某个变量的边缘分布时，需要考虑另一个变量的所有取值情况：\n\n\n\n1.2 分布律\n联合分布率\n联合分布率是二维离散型随机变量的分布律，其表达式为：\n二维联合分布律满足\n\n\n边缘分布律\n边缘分布律是以为随机比那量的分布律，利用二维分布率计算一维变量的分布律：\n\n\n\ne.g. 以下是的联合分布律，求解边缘分布律\n\n\n\n\n\n\n\n\n\n\n0.4\n0.2\n\n\n\n0.1\na\n\n\nans.\n易知，，则得\n则的边缘分布律为：的边缘分布律为：\n1.3 概率密度函数\n联合概率密度函数\n设的联合分布函数为，若存在非负使得，则称为变量的联合概率密度函数\n联合概率密度函数满足\n\n\n边缘概率密度函数\n边缘概率密度函数是一维随机变量的概率密度函数，利用二维概率密度函数进行计算，在计算某个变量的密度函数时，需要对另一个变量的所有情况进行积分：\n\n\n\ne.g. 计算下列概率密度函数的值，及边缘密度函数其他ans.\n(1) 求解的值：得\n(2) 求解边缘密度函数\n1.4 条件分布函数条件分布的基本公式为：\n\n离散型条件分布函数\n\n设，在事件发生的情况下，事件发生的条件概率为：    同理，求救的条件概率时有如下公式：  \n\n\n连续型条件分布\n\n设，则在的条件下，的条件概率密度函数为：\n设，则在的条件下，的条件概率密度函数为：\n\n\n\n2. 二维随机变量函数分布2.1 二维均匀分布\n二维均匀分布的联合密度表达式为：    其中是区域的面积\n\ne.g. 服从区域上的均匀分布，为，求解\nans.\n由题意得：所以\n2.2 二维正态分布\n二维正态分布的联合密度表达式如下：  \n\n若二维正态分布为，则，其中，是两个变量的相关系数\n\n\n3. 随机变量的独立性TODO…\n\n\n\n\n\n\n\n\n\n知乎专栏没有讲清楚\n第六章 数理统计基本概念1. 基本概念1.1 统计量\n统计量是样本的无参函数，即不含任何未知数的样本函数\n\n2. 样本常用统计量2.1 样本均值\n样本均值表示为：\n\n2.2 样本方差\n样本方差表示为： \n\n\n\n\n\n\n\n\n\n\n[问] 为什么样本方差的分母是?\n[答] 参考知乎回答为什么样本方差（sample variance）的分母是 n-1？\n2.3 样本k阶原点矩\n样本k阶原点矩表示为： ，其中，样本均值为一阶原点矩\n\n2.4 样本的k阶中心矩\n样本的k阶中心矩表示为： \n\n4. 常用的统计分布性质以下为常用的六个统计分布性质：\n设总体，是来自正态总体的简单样本，则\n\n\n\n\n\n\n与相互独立\n\n","slug":"MathematicalStatistics","date":"2021-04-09T10:54:20.000Z","categories_index":"notes","tags_index":"Algorithm,ACM,Mathematical Statistics","author_index":"𝚂𝚞𝚗𝚒𝚜𝚝𝙲"},{"id":"0e67ea3c9c88de3508878bdcc5b54c50","title":"训练笔记 - 数论与数学","content":"数论板块1. 裴蜀引理预备知识：\n\n约数和倍数: 如果一个整数能够被正整数整除，则存在另一个整数使得或者。称是的约数或因数，是的倍数。正整数的两个倍数的和或者差仍然是的倍数。\n公约数和最大公约数: 如果正整数同时是两个整数，的约数，称为和的公约数，和所有公约数中最大的数称为最大公约数。是所有数的倍数。所有的正整数都是的约数。\n带余除法: 给定一个整数和一个整数，总能找到一个整数使得，其中，称为被除的余数。总能的证明: 画数轴，为单位，总能落在数轴上\n素数: 一个大于的正整数，如果只有和它本身两个约数，就称它为素数。  两个整数的最大公约数如果为，则称这两个数互素。\n\n裴蜀引理： 给定两个整数和，假设他们的最大公约数是，当且仅当是的倍数时，下列方程有整数解:\n证明：\n(1) 若，则. 这时定理显然成立。\n(2) 若不等于：\n记, 对，两边同时除以，可得，其中。\n转证。由带余除法:\n所以，由和推出\n\n再结合推出\n\n再结合推出\n\n\n再结合推出\n\n再结合推出\n\n再结合推出\n\n证明完毕。\n推论\n\n当且仅当下面方程有整数解时，两个整数和互素：\n如果素数整除两个整数和的乘积，则必然会整除或\n\n2. 辗转相除法辗转相除法是求两个数的最大公约数的算法。\n辗转相除法是求两个数的最大公约数的算法，对于而言，其有以下步骤:\n\n求\n令，重复步骤\n当时，为所求最大公约数\n\n使用辗转相除法时，其步骤如下，以求和的最大公约数为例：\n\n此时求得和的最大公约数为。\n辗转相除法(欧几里得算法)的C++实现如下：\n/**\n * @description: 欧几里得算法的递归实现\n * @param {int} a 求最大公约数的某数\n * @param {int} b 求最大公约数的某数\n * @return {int} 求得的最大公约数\n */\nint gcd(int a, int b) \n{\n    return b ? gcd(b, a % b) : a;\n}\n\n/**\n * @description: 欧几里得算法的循环实现\n * @param {int} a 求最大公约数的某数\n * @param {int} b 求最大公约数的某数\n * @return {int} 求得的最大公约数\n */\nint gcd(int a, int b) \n{\n    int c = a % b;\n    while (c != 0) \n    {\n        a = b;\n        b = c;\n        c = a % b; \n    }\n    return b;\n}\n\n3. 算术基本定理算术基本定理： 如果不考虑排列次序的话，每个大于1的自然数都只能有一种方式分解成若干个素数的乘积。\n可以理解为：\n\n存在性： 每个大于的自然数都可以分解成素数的乘积\n唯一性： 这种分解不考虑次序排列的意义下是唯一的\n\n证明：\n若是素数，则。若是合数，则，对重复上过程，可得素数集。\n则任意，均可以分解成素数的乘积，证得存在性。\n设\n\n则，即。\n又素数集，则当时，。\n所以必定有，才能使得。\n令，重复上述过程，可以得知对于任意，必然有一个与之对应。\n所以必然有一种排列使得，即在不考虑排列的情况下，这种分解是唯一的，唯一性得证。\n证明完毕。\n4. 最大公约数与最小公倍数的关系如果正整数同时是两个整数，的约数，称为和的公约数，和所有公约数中最大的数称为最大公约数，记作。\n如果正整数同时是两个整数的倍数，称为和的公倍数，和所有公倍数中最小的数称最小公倍数，记作。\n最大公约数与最小公倍数的关系： 对于任意的正整数，其最大公约数与最小公倍数满足下述关系：\n\n证明：\n若中某数等于，满足上述关系。\n已知任意大于一的整数都可以表示为若干个素数的乘积，则对于：\n\n其中素数集，所以的最大公约数可以表示为：\n\n的最小公倍数可以表示为：\n\n而对于任意，都有恒成立。\n则有：\n\n证明完毕。\n5. 素数5.0 以内的素数有几个素数计算函数：\n小于或等于的素数的个数，可以用表示，有：\n\n在时，此函数的误差已经小于了。通常情况下，可以用此函数估计素数的个数。\n5.1 如何判断素数复杂度算法：\n判断一个大于的整数是否为素数，最简单的方法便是根据素数的定义去判断，即使用从到之间的所有整数与做除法，看能否与整除，其代码实现如下：\nbool isPrime(int n) \n{\n\tfor (int i = 2; i &lt; n; ++i)\n\t{\n\t\tif (n % i == 0) \n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n复杂度算法：\n在上面的算法中，其实并不需要按照定义一直判断到，我们只需要判断从到之间的整数就可以了。\n证明：\n若不是素数，则其可以表示为，我们不妨令。\n此时我们知道可能取得最大值时，有，即，此时。\n所以，即若不是素数，其必有一个因数在区间。\n证明完毕。\n其代码实现较上文差别不大，此处就不单独展示了。\n(选学)Fermat素性测试：\n我们可以根据费马小定理得出一种检验素数的思路：\n不断地选取在中的基，并检验是否每次都有 \n其C++实现如下：\n/**\n * @description: 费马素性测试\n * @param {int} n 要判断的数n\n * @return {bool} n是否为素数，是则返回true\n */\nbool millerRabin(int n) {\n    if (n &lt; 3) \n    {\n        return n == 2;\n    }\n\n    // test_time为测试次数,建议设为不小于8的整数以保证正确率,但也不宜过大,否则会影响效率\n    for (int i = 1; i &lt;= test_time; ++i) \n    {\n        int a = rand() % (n - 2) + 2;\n        if (quickPow(a, n - 1, n) != 1) \n        {\n            return false;\n        }\n    }\n    return true;\n}\n\n但是费马小定理的逆定理并不成立，这个方法也不是完全准确的，需要额外考虑Carmichael Number。这个方法的时间复杂度大致为。\n5.2 如何生成素数在上面我们知道了如何判断一个数是不是素数，那么引申出了另一个问题，我们要如何求某个区间内的所有素数呢？\n我们当然可以按照上面的方法对区间内每一个数都进行一次判断，但我们稍作分析就知道，判断一个数是不是素数的时间复杂度是，那么判断个数是不是素数的时间复杂度就是，这其实是一个十分费时的算法，通常情况下会被比赛卡超时。\n然后我们就要讲到我们的两大法宝： 埃拉托斯特尼筛法和线性筛法\n埃氏筛\n埃氏筛法的基本原理是：如果找到一个质数，那么这个质数的倍数都不是质数。\n我们只需要将范围内的所有数从头开始并标记出他们的倍数，遇到标记过的数就跳过，直到标记到最后为止。其过程表示如下：\n\n\n这个过程的C++实现如下：\n// include &lt;cstdlib&gt;\n\n/**\n * @description: 埃拉托斯特尼筛法\n * @param {int} n 要求的素数区间，即求[2, n]之间的素数\n * @return {*} isPrime为true的均为素数\n */\nvoid EratosthenesMethod(int n) \n{\n    bool *tag = new bool[n];\n    for (int i = 0; i &lt; n; ++i) \n    {\n        isPrime[i] = true;\n    }\n\n    for (int i = 2; i * i &lt; n; ++i) \n    {\n        if (isPrime[i]) \n        {\n            for (int j = i * i; j &lt; n; j += i) \n            {\n                isPrime[j] = false;\n            }\n        }\n    }\n}\n\n上面的算法可以预先处理每个数都有的质因数以提升效率。其复杂度为\n想看其复杂度计算过程吗？\n\n\n\n\n\n\n\n\n\n参考自OI-Wiki.org\n可以直接观察知埃氏筛法的复杂度为\n\n调和级数，由唯一分解定理可得：\n\n两边同时取对数，得：\n\n易知，由微积分基本定理：\n\n得\n\n即\n\n用法表示即为\n线性筛\n埃氏筛法仍有优化空间，它会将一个合数重复多次标记。有没有什么办法省掉无意义的步骤呢？答案是肯定的。\n如果能让每个合数都只被标记一次，那么时间复杂度就可以降到了。\n其C++代码实现如下：\n/**\n * @description: 欧拉筛法\n * @param {int} n 要求的n以内的素数\n * @return {void}\n */\nvoid EulerMethod (int n) {\n\tunsigned long long *phi = new unsigned long long[n];\n\tphi[1] = 1;\n\tint cnt = 0;\n\n\tfor (int i = 2; i &lt; n; ++i) \n\t{\n\t\tif (!vis[i])\n\t\t{\n\t\t\tphi[i] = i - 1;\n\t\t\tpri[cnt++] = i;\n\t\t}\n\n\t\tfor (int j = 0; j &lt; cnt; ++j) \n\t\t{\n\t\t\tif (1ll * i * pri[j] &gt;= n) // 此处1ll是在计算时使用long long类型，避免溢出\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvis[i * pri[j]] = 1;\n\t\t\tif (i % pri[j]) \n\t\t\t{\n\t\t\t\tphi[i * pri[j]] = phi[i] * (pri[j] - 1);\n\t\t\t} \n\t\t\telse \n\t\t\t{\n\t\t\t\tphi[i * pri[j]] = phi[i] * pri[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n(选学) min_25筛法\n这个筛法是min_25大佬在比赛的时候发明的筛法，其时间复杂度为，其中很多内容我们也不会需要同学们自己理解\n\n\n\n\n\n\n\n\n\n本节参考了大量资料：\n\nSum of Multiplicative Function - min_25\nmin_25筛 - 租酥雨\nmin25筛学习笔记&amp;模板详解 - Flyppy_White\n\n首先我们定义一些符号和说明：\n\n并且素数集，是所有素数中第小的素数，特别定义\n表示最小的质因数，特别定义\n是一个关于的项数较少的多项式或者可以快速求值的多项式，需要能够快速求值\n\n\n\n我们不难知道，通过枚举每个的最小质因子及其次数可以得到的递推式\n\n最后一步推导基于这样一个事实：\n对于满足的，有：\n\n即\n\n其C++实现，请转到min25筛学习笔记&amp;模板详解 - Flyppy_White\n数学板块1. 矩阵快速幂1.1 矩阵这一点回去找线性代数老师。\n1.2 快速幂对于任意的数，都可以通过位运算将它化为多个的幂的和的形式。\n例如:\n\n但是，当指数特别大的时候，如，我们想要计算它的时候，就得计算次乘法才能得出结果。这样我们就得等很久才能计算完毕，那么有没有什么办法能够加速这一过程呢？\n亲亲，有的！这个方法就是快速幂：\n以为例：\n\n同时，根据常识 常人所不知道的知识：\n\n我们知道其时间复杂度为，对于式的幂只需要次位运算即可求得：\n，\n即：\n\n我们再再依次求的幂，求完相加次数就变为了次乘法和次加法，一共次运算。但实际编程中后一次运算的结果可以由前一次运算的结果迭代而来。\n即：\n\n\n\n\n\n\n\n\n\n由于位运算帮助我们计算是否该取该数，实际上运算次数是次乘法运算、次加法运算和次位运算，一共次。由次运算降低为次运算，效率上大大提高。这就是快速幂。\n快速幂的C++实现如下：\n/**\n * @description: 快速幂，计算base^index\n * @param {int} base 底数\n * @param {int} index 指数\n * @return {int} 计算结果base^index\n */\nint quick_power (int base, int index)\n{\n    int result = 1;\n    while (index)\n    {\n        if (index &amp; 1)\n        {\n            result *= base;\n        }\n        base *= base;\n        index = index &gt;&gt; 1;\n    }\n    return result;\n}\n\n1.3 矩阵快速幂现在我们已经知道了什么是矩阵，什么是快速幂。聪明的同学们一定能很简单的推出什么是矩阵快速幂吧！\n那么什么是矩阵快速幂呢？答案当然是矩阵的快速幂啦！\n\n\n\n\n\n\n\n\n\n下面为了叙述方便，我们使用方阵举例，矩阵也有同样的性质。\n对于一个方阵,它的次幂为：\n\n对于，需要做次乘法运算。由整数快速幂的计算方法，你可能已经想到了，方阵也可以简化运算。没错，这就是矩阵快速幂。\n如:\n同样后面的运算结果可以由前面的运算结果迭代而来:\n\n\n\n\n运算过程和整数快速幂相同，而两个矩阵的乘法运算我们早就刻进DNA啦 我们也能没什么难度地实现。\n\b\b那么下面就是方阵快速幂的C++代码实现了：\n/**\n * @description: 方阵快速幂\n * @param {SquareMatrix} A 快速幂的底，即方阵A\n * @param {int} n 指数\n * @return {SquareMatrix} 计算结果，即A^n\n */\nSquareMatrix matrix_quick_power(SquareMatrix A,int n){\n    SquareMatrix base = A;\n    SquareMatrix result;\n    //对B进行初始化，初始化为单位阵\n    for(int i = 0;i &lt; N;i++){\n        for(int j = 0;j &lt; N;j++){\n            if(i == j){\n                result.matrix[i][j] = 1;\n            }else{\n                result.matrix[i][j] = 0;\n            }\n        }\n    }\n    while(n)\n    {\n        if(n&amp;1)\n        {\n            result = mul(result,base);\n        }\n        base = mul(base,base);\n        n = n&gt;&gt;1;\n    }\n    return result;\n}\n\n那么矩阵快速幂有什么用呢？请同学们转到快速幂仔细阅读。 不是懒不写啊，已经加粗了，自己没看错过了后果自负。\n2. 高精度计算高精度计算(Arbitrary-Precision Arithmetic)，也被称作大整数(bignum)计算，运用了一些算法结构来支持更大整数间的运算(数字大小超过语言内建整型)。\n此节难度较低，同学们仅需知道竖式是怎么算的就行了，模拟实现这些过程就完事了。\n不会建议退学重读小学。\n可以参考高精度的模版：高精度计算\n3. 组合数学排列组合是组合数学中的基础。\n\n排列就是指从给定个数的元素中取出指定个数的元素进行排序\n组合则是指从给定个数的元素中仅仅取出指定个数的元素，不考虑排序。\n\n排列组合的中心问题是研究给定要求的排列和组合可能出现的情况总数。排列组合与古典概率论关系密切。\n在我们所有的暴力、枚举题目中，无遗漏地进行排列组合是我们解题的关键。\n3.1 排列组合加法原理、乘法原理、二项式定理啥的如果不知道自己回去补课，此处重点介绍全排列。\n什么是全排列呢？以三个数(状态)为例，它们的全排列为：\n\n对于种状态的全排列而言，它们有种情况。\n对于而言，我们可以很轻松地写出对应的代码：\nvoid printPermutation () \n{\n    for (int i = 1; i &lt;= 3; ++i) \n    {\n        for (int j = 1; j &lt;= 3; ++j) \n        {\n            for (int k = 1; k &lt;= 3; ++k) \n            {\n                if (i == j || i == k || j == k) \n                {\n                    continue;\n                }\n                else \n                {\n                    print(i, j, k);\n                }\n            }\n        }\n    }\n}\n\n在状态数量较少的时候，我们可以使用循环来进行全排列，但是在状态较多的时候，循环就显得过于繁复，同时循环也无法处理状态数量未知的全排列。此时我们就应该考虑其他方法实现全排列了。\n递归实现：\n我们可以发现，全排列是把已知的所有状态按照不同的顺序分别展示出来，那么我们就不难想到我们可以使用图结构和深度优先搜索来实现这个需求，我们只需要从不同的节点出发，遍历有所有状态组成的图即可。\n其C++实现如下：\nvoid printPermutation(int x, int n, bool *Visited, int *answer)\n{\n\tif (x &gt; n)\n\t{\n\t\tfor (int i = 0; i &lt; n; i++)\n\t\t{\n\t\t\tprint(answer[i]);\n\t\t}\n\t}\n\tfor (int i = 0; i &lt; n; i++)\n\t{\n\t\tif (!Visited[i])\n\t\t{\n\t\t\tanswer[x-1] = i+1;\n\t\t\tVisited[i] = true;\n\t\t\tprintPermutation(x+1, n, Visited, answer);\n\t\t\tVisited[i] = false;\n\t\t}\n\t}\n}\n\n当然，建立树并对树进行遍历也是可以实现的，更多的写法可以转到P1706 全排列问题 题解 - 洛谷\nSTL实现：\n在C++ STL中，有一个函数叫做全排列函数，它分为next_permutation和prev_permutation，作用是求当前排列的上一个排列和下一个排列。\nbool next_permutation(iterator start,iterator end);\nbool prev_permutation(iterator start,iterator end);\n\n其中start是排列状态的开始位置，end是排列状态的结束位置，返回值是能否找到下一个/上一个排列，能则返回true，不能则返回false。\n同时，此函数的上一项、下一项按照字典序进行排列。\n至于具体的使用方法，可以转到C++STL中全排列函数next_permutation的使用 - AC_Gibson\n3.2 容斥原理我们先引入一个问题：\n\n\n\n\n\n\n\n\n\n假设班里有个学生喜欢数学，个学生喜欢语文，个学生喜欢编程，班里至少喜欢一门学科的有多少个学生呢？\n是个吗？显然不是的，因为有些学生可能同时喜欢数学和语文，或者语文和编程，甚至还有可能三者都喜欢。\n对于上面的问题，其很有可能是下图这种情况：\n\n\n现在我们引入容斥原理。\n设种元素有种不同的属性，而第种属性称为，拥有属性的元素构成集合，那么有：\n\n即：\n\n看懂了吗？是不是超级简单。 上面的乱七八糟的公式其实就是在做一件事：\n先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复。\n这种原理在我们的程序设计中有着广泛的应用。\n4. 概率论这玩意主要以理论为主，与计算机没有直接交集，此处跳过。\n5. (选学)博弈论博弈论，是经济学的一个分支，主要研究具有竞争或对抗性质的对象，在一定规则下产生的各种行为。博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。\n通俗地讲，博弈论主要研究的是：在一个游戏中，进行游戏的多位玩家的策略。\n下面是一个Nim游戏的示例：\n堆物品，每堆有个，两个玩家轮流取走任意一堆的任意个物品，但不能不取。取走最后一个物品的人获胜。\n\n\n\n\n\n\n\n\n\n例如，如果现在有堆物品，而每堆分别有个，那么可以取走第堆中的个物品，局面就变成了；或者也可以取走第堆的个物品，局面就变成了。\n如果现在的局面为，甲取走了第堆的个物品，也就是取走了最后一个物品，此时甲获胜。\n如果将每个状态视为一个节点，再从每个状态向它的后继状态连边，我们就可以得到一个博弈状态图。如果节点表示局面为时的状态，则我们可以画出下面的博弈图(由于篇幅有限，故仅显示部分状态节点和部分边)：\n\n\n定义必胜状态为先手必胜的状态，必败状态为先手必败的状态。\n通过推理，我们可以得出下面三条定理：\n\n定理 1：没有后继状态的状态是必败状态。\n定理 2：一个状态是必胜状态当且仅当存在至少一个必败状态为它的后继状态。\n定理 3：一个状态是必败状态当且仅当它的所有后继状态均为必胜状态.\n\n对于定理 1，如果游戏进行不下去了，那么这个玩家就输掉了游戏。\n对于定理 2，如果该状态至少有一个后继状态为必败状态，那么玩家可以通过操作到该必败状态；此时对手的状态为必败状态——对手必定是失败的，而相反地，自己就获得了胜利。\n对于定理 3，如果不存在一个后继状态为必败状态，那么无论如何，玩家只能操作到必胜状态；此时对手的状态为必胜状态——对手必定是胜利的，自己就输掉了游戏。\n现在我们定义Nim和，记作：\n\n则当且仅当时，该状态为必败状态，否则为必胜状态。\n该结论的证明过程可见Nim游戏 - 博弈论\n为了计算这个，我们引入函数与函数：\n\n即函数计算不属于集合中的最小非负整数。\n\n对于由个有向图游戏组成的组合游戏，设它们的起点分别为，则有定理：\n当且仅当:\n\n这个游戏是先手必胜的。\n我们就可以使用函数与的结论来计算博弈论中的必胜问题了。\n6. 进制转换讲过太多次，不想再讲了。\n","slug":"NumberTheory","date":"2021-04-07T19:19:19.000Z","categories_index":"notes","tags_index":"Number Theory,Algorithm,ACM","author_index":"𝚂𝚞𝚗𝚒𝚜𝚝𝙲"},{"id":"7f3e2fd4afd1d0c67545b22531185c26","title":"2019级数据结构期中测试题目与详解","content":"由于这次数据结构期中考试的题目都做对了，故写此题解与大家分享。\n题目下面程序段的时间复杂度是( )\ni = 1;\nwhile (i &lt;= n) {\n    i = i * 3; \n}\n\n如果对线性表的操作只有两种，即删除第一个元素，在最后一个元素的后面插入新元素，则最好使用( )\nA. 只有表头指针没有表尾指针的循环单链表B. 只有表尾指针没有表头指针的循环单链表C. 非循环双链表D. 循环双链表\n一个栈的进栈序列是，则栈的不可能的输出序列是( )\nA. B. C. D. \n若已知一个栈的进栈序列是，其输出序列为，若，则 为( )\nA. B. C. D. 不确定\n队列的“先进先出”特性是指( )\nA. 最早插入队列中的元素总是最后被删除B. 当同时进行插入、删除操作时，总是插入操作优先C. 每当有删除操作时，总是要先做一次插入操作D. 每次从队列中删除的总是最早插入的元素\n若A是按列序为主序进行存储的的二维数组,其每个元素占用3个存储单元,并且A[0][0]的存储地址为1000,元素A[1][3]的存储地址为( )，该数组共占用( )个存储单元。\n表达式的后缀表达式为( )。\n已知Lnode是单链表节点的类型，请说明下面函数的功能。\nvoid MADE(Lnode * &amp;H1) {\n    Lnode *p;\n    p = H1;\n    H1 = NULL;\n    while (p != NULL) {\n        Lnode *q = p;\n        p = p-&gt;next;\n        q-&gt;next = H1;\n        H1 = q;\n    } \n}\n\n题解\n设计基本语句的执行次数为，则有。因此。\n\n因为需要在最后一个元素的后面插入元素，则我们只需要知道最后一个元素的位置即尾指针即 可，则A项不满足条件，又需要删除第一个元素，则我们需要知道第一个元素的上一个元素的位 置即头指针或者循环链表的尾指针，故知B项满足题意，且双链表的空间复杂度比单链表要高， 故本题选B。\n\n若进栈顺序为A, B, C，则不可能的出栈情况为C, A, B，观察得知C项出现了A, B, C进栈而 C, A, B出栈的情况，则C项是不可能的输出序列。\n\n易知进栈序列为1 → n，而第一个出栈的元素为n，则可以推断出所有元素都进栈了以后才开始 抛出元素，则出栈顺序为n→1，即n,n−1,n−2,⋯,3,2,1，则pi =n−i+1，选择 C项。\n\n概念题，选D。\n\n注意数组按列序存储即可，画图解决问题，答案为\n\n使用课本上的方法模拟一遍即可解决问题，答案为[]\n\n答案为： 将H1及其后面的所有节点反序。\n 这个函数中的while循环中，在p指针不为空的时候，每进行一次循环，都会将p和p-1间的链接顺序从p − 1 → p转换为p → p − 1，并且将p指针向下一个元素迭代。\n 当循环完成时，若原来的H1及其后面的节点顺序为:\n H1 -&gt; H2 -&gt; ... -&gt; Hn -&gt; NULL\n\n 则执行结果为:\n NULL &lt;- H1 &lt;- H2 &lt;- ... &lt;- Hn\n\n\n\n","slug":"DataStructureAnswer","date":"2020-10-23T07:20:53.000Z","categories_index":"answer","tags_index":"Answer,DataStucture","author_index":"𝚂𝚞𝚗𝚒𝚜𝚝𝙲"}]